/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

package org.openapis.openapi.models.components;


import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import java.lang.Long;
import java.lang.Override;
import java.lang.String;
import java.util.Objects;
import java.util.Optional;
import org.openapis.openapi.utils.Utils;


public class ActiveCompanies {

    /**
     * unique identifier for the company associated with the invoice data
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("company_uuid")
    private Optional<String> companyUuid;

    /**
     * The number of active employees the company was or will be invoiced for that invoice period. Active employees are calculated as the count of onboarded employees hired before the end of the invoice period and not terminated before the start of the invoice period.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("active_employees")
    private Optional<Long> activeEmployees;

    /**
     * The number of active contractors the company was or will be invoiced for that invoice period. Active contractors are calculated as any contractor with an active contractor payment during the invoice period.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("active_contractors")
    private Optional<Long> activeContractors;

    /**
     * The first invoice period for the company. This will either be the invoice period of the first invoice-able event (first payroll or contractor payment) or the date they migrated to embedded, whichever is later.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("initial_invoice_period")
    private Optional<String> initialInvoicePeriod;

    @JsonCreator
    public ActiveCompanies(
            @JsonProperty("company_uuid") Optional<String> companyUuid,
            @JsonProperty("active_employees") Optional<Long> activeEmployees,
            @JsonProperty("active_contractors") Optional<Long> activeContractors,
            @JsonProperty("initial_invoice_period") Optional<String> initialInvoicePeriod) {
        Utils.checkNotNull(companyUuid, "companyUuid");
        Utils.checkNotNull(activeEmployees, "activeEmployees");
        Utils.checkNotNull(activeContractors, "activeContractors");
        Utils.checkNotNull(initialInvoicePeriod, "initialInvoicePeriod");
        this.companyUuid = companyUuid;
        this.activeEmployees = activeEmployees;
        this.activeContractors = activeContractors;
        this.initialInvoicePeriod = initialInvoicePeriod;
    }
    
    public ActiveCompanies() {
        this(Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty());
    }

    /**
     * unique identifier for the company associated with the invoice data
     */
    @JsonIgnore
    public Optional<String> companyUuid() {
        return companyUuid;
    }

    /**
     * The number of active employees the company was or will be invoiced for that invoice period. Active employees are calculated as the count of onboarded employees hired before the end of the invoice period and not terminated before the start of the invoice period.
     */
    @JsonIgnore
    public Optional<Long> activeEmployees() {
        return activeEmployees;
    }

    /**
     * The number of active contractors the company was or will be invoiced for that invoice period. Active contractors are calculated as any contractor with an active contractor payment during the invoice period.
     */
    @JsonIgnore
    public Optional<Long> activeContractors() {
        return activeContractors;
    }

    /**
     * The first invoice period for the company. This will either be the invoice period of the first invoice-able event (first payroll or contractor payment) or the date they migrated to embedded, whichever is later.
     */
    @JsonIgnore
    public Optional<String> initialInvoicePeriod() {
        return initialInvoicePeriod;
    }

    public final static Builder builder() {
        return new Builder();
    }

    /**
     * unique identifier for the company associated with the invoice data
     */
    public ActiveCompanies withCompanyUuid(String companyUuid) {
        Utils.checkNotNull(companyUuid, "companyUuid");
        this.companyUuid = Optional.ofNullable(companyUuid);
        return this;
    }

    /**
     * unique identifier for the company associated with the invoice data
     */
    public ActiveCompanies withCompanyUuid(Optional<String> companyUuid) {
        Utils.checkNotNull(companyUuid, "companyUuid");
        this.companyUuid = companyUuid;
        return this;
    }

    /**
     * The number of active employees the company was or will be invoiced for that invoice period. Active employees are calculated as the count of onboarded employees hired before the end of the invoice period and not terminated before the start of the invoice period.
     */
    public ActiveCompanies withActiveEmployees(long activeEmployees) {
        Utils.checkNotNull(activeEmployees, "activeEmployees");
        this.activeEmployees = Optional.ofNullable(activeEmployees);
        return this;
    }

    /**
     * The number of active employees the company was or will be invoiced for that invoice period. Active employees are calculated as the count of onboarded employees hired before the end of the invoice period and not terminated before the start of the invoice period.
     */
    public ActiveCompanies withActiveEmployees(Optional<Long> activeEmployees) {
        Utils.checkNotNull(activeEmployees, "activeEmployees");
        this.activeEmployees = activeEmployees;
        return this;
    }

    /**
     * The number of active contractors the company was or will be invoiced for that invoice period. Active contractors are calculated as any contractor with an active contractor payment during the invoice period.
     */
    public ActiveCompanies withActiveContractors(long activeContractors) {
        Utils.checkNotNull(activeContractors, "activeContractors");
        this.activeContractors = Optional.ofNullable(activeContractors);
        return this;
    }

    /**
     * The number of active contractors the company was or will be invoiced for that invoice period. Active contractors are calculated as any contractor with an active contractor payment during the invoice period.
     */
    public ActiveCompanies withActiveContractors(Optional<Long> activeContractors) {
        Utils.checkNotNull(activeContractors, "activeContractors");
        this.activeContractors = activeContractors;
        return this;
    }

    /**
     * The first invoice period for the company. This will either be the invoice period of the first invoice-able event (first payroll or contractor payment) or the date they migrated to embedded, whichever is later.
     */
    public ActiveCompanies withInitialInvoicePeriod(String initialInvoicePeriod) {
        Utils.checkNotNull(initialInvoicePeriod, "initialInvoicePeriod");
        this.initialInvoicePeriod = Optional.ofNullable(initialInvoicePeriod);
        return this;
    }

    /**
     * The first invoice period for the company. This will either be the invoice period of the first invoice-able event (first payroll or contractor payment) or the date they migrated to embedded, whichever is later.
     */
    public ActiveCompanies withInitialInvoicePeriod(Optional<String> initialInvoicePeriod) {
        Utils.checkNotNull(initialInvoicePeriod, "initialInvoicePeriod");
        this.initialInvoicePeriod = initialInvoicePeriod;
        return this;
    }
    
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        ActiveCompanies other = (ActiveCompanies) o;
        return 
            Objects.deepEquals(this.companyUuid, other.companyUuid) &&
            Objects.deepEquals(this.activeEmployees, other.activeEmployees) &&
            Objects.deepEquals(this.activeContractors, other.activeContractors) &&
            Objects.deepEquals(this.initialInvoicePeriod, other.initialInvoicePeriod);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(
            companyUuid,
            activeEmployees,
            activeContractors,
            initialInvoicePeriod);
    }
    
    @Override
    public String toString() {
        return Utils.toString(ActiveCompanies.class,
                "companyUuid", companyUuid,
                "activeEmployees", activeEmployees,
                "activeContractors", activeContractors,
                "initialInvoicePeriod", initialInvoicePeriod);
    }
    
    public final static class Builder {
 
        private Optional<String> companyUuid = Optional.empty();
 
        private Optional<Long> activeEmployees = Optional.empty();
 
        private Optional<Long> activeContractors = Optional.empty();
 
        private Optional<String> initialInvoicePeriod = Optional.empty();  
        
        private Builder() {
          // force use of static builder() method
        }

        /**
         * unique identifier for the company associated with the invoice data
         */
        public Builder companyUuid(String companyUuid) {
            Utils.checkNotNull(companyUuid, "companyUuid");
            this.companyUuid = Optional.ofNullable(companyUuid);
            return this;
        }

        /**
         * unique identifier for the company associated with the invoice data
         */
        public Builder companyUuid(Optional<String> companyUuid) {
            Utils.checkNotNull(companyUuid, "companyUuid");
            this.companyUuid = companyUuid;
            return this;
        }

        /**
         * The number of active employees the company was or will be invoiced for that invoice period. Active employees are calculated as the count of onboarded employees hired before the end of the invoice period and not terminated before the start of the invoice period.
         */
        public Builder activeEmployees(long activeEmployees) {
            Utils.checkNotNull(activeEmployees, "activeEmployees");
            this.activeEmployees = Optional.ofNullable(activeEmployees);
            return this;
        }

        /**
         * The number of active employees the company was or will be invoiced for that invoice period. Active employees are calculated as the count of onboarded employees hired before the end of the invoice period and not terminated before the start of the invoice period.
         */
        public Builder activeEmployees(Optional<Long> activeEmployees) {
            Utils.checkNotNull(activeEmployees, "activeEmployees");
            this.activeEmployees = activeEmployees;
            return this;
        }

        /**
         * The number of active contractors the company was or will be invoiced for that invoice period. Active contractors are calculated as any contractor with an active contractor payment during the invoice period.
         */
        public Builder activeContractors(long activeContractors) {
            Utils.checkNotNull(activeContractors, "activeContractors");
            this.activeContractors = Optional.ofNullable(activeContractors);
            return this;
        }

        /**
         * The number of active contractors the company was or will be invoiced for that invoice period. Active contractors are calculated as any contractor with an active contractor payment during the invoice period.
         */
        public Builder activeContractors(Optional<Long> activeContractors) {
            Utils.checkNotNull(activeContractors, "activeContractors");
            this.activeContractors = activeContractors;
            return this;
        }

        /**
         * The first invoice period for the company. This will either be the invoice period of the first invoice-able event (first payroll or contractor payment) or the date they migrated to embedded, whichever is later.
         */
        public Builder initialInvoicePeriod(String initialInvoicePeriod) {
            Utils.checkNotNull(initialInvoicePeriod, "initialInvoicePeriod");
            this.initialInvoicePeriod = Optional.ofNullable(initialInvoicePeriod);
            return this;
        }

        /**
         * The first invoice period for the company. This will either be the invoice period of the first invoice-able event (first payroll or contractor payment) or the date they migrated to embedded, whichever is later.
         */
        public Builder initialInvoicePeriod(Optional<String> initialInvoicePeriod) {
            Utils.checkNotNull(initialInvoicePeriod, "initialInvoicePeriod");
            this.initialInvoicePeriod = initialInvoicePeriod;
            return this;
        }
        
        public ActiveCompanies build() {
            return new ActiveCompanies(
                companyUuid,
                activeEmployees,
                activeContractors,
                initialInvoicePeriod);
        }
    }
}

