/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

package org.openapis.openapi.models.components;


import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import java.lang.Boolean;
import java.lang.Double;
import java.lang.Override;
import java.lang.String;
import java.lang.SuppressWarnings;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import org.openapis.openapi.utils.Utils;
import org.openapitools.jackson.nullable.JsonNullable;


public class PayrollEmployeeCompensationsType {

    /**
     * The UUID of the employee.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("employee_uuid")
    private Optional<String> employeeUuid;

    /**
     * This employee will be excluded (skipped) from payroll calculation and will not be paid for the payroll. Cancelling a payroll would reset all employees' excluded back to false.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("excluded")
    private Optional<Boolean> excluded;

    /**
     * The current version of this employee compensation. This field is only available for prepared payrolls. See the [versioning guide](https://docs.gusto.com/embedded-payroll/docs/idempotency) for information on how to use this field.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("version")
    private Optional<String> version;

    /**
     * The employee's gross pay, equal to regular wages + cash tips + payroll tips + any other additional earnings, excluding imputed income. This value is only available for processed payrolls.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("gross_pay")
    private JsonNullable<Double> grossPay;

    /**
     * The employee's net pay, equal to gross_pay - employee taxes - employee deductions or garnishments - cash tips. This value is only available for processed payrolls.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("net_pay")
    private JsonNullable<Double> netPay;

    /**
     * The employee's check amount, equal to net_pay + reimbursements. This value is only available for processed payrolls.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("check_amount")
    private JsonNullable<Double> checkAmount;

    /**
     * The employee's compensation payment method.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("payment_method")
    private JsonNullable<? extends PayrollEmployeeCompensationsTypePaymentMethod> paymentMethod;

    /**
     * Custom text that will be printed as a personal note to the employee on a paystub.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("memo")
    private JsonNullable<String> memo;

    /**
     * An array of fixed compensations for the employee. Fixed compensations include tips, bonuses, and one time reimbursements. If this payroll has been processed, only fixed compensations with a value greater than 0.00 are returned. For an unprocessed payroll, all active fixed compensations are returned.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("fixed_compensations")
    private Optional<? extends List<FixedCompensations>> fixedCompensations;

    /**
     * An array of hourly compensations for the employee. Hourly compensations include regular, overtime, and double overtime hours. If this payroll has been processed, only hourly compensations with a value greater than 0.00 are returned. For an unprocessed payroll, all active hourly compensations are returned.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("hourly_compensations")
    private Optional<? extends List<HourlyCompensations>> hourlyCompensations;

    /**
     * An array of all paid time off the employee is eligible for this pay period.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("paid_time_off")
    private Optional<? extends List<PayrollEmployeeCompensationsTypePaidTimeOff>> paidTimeOff;

    /**
     * An array of employee benefits for the pay period. Benefits are only included for processed payroll when the include parameter is present.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("benefits")
    private Optional<? extends List<Benefits>> benefits;

    /**
     * An array of employee deductions for the pay period. Deductions are only included for processed payroll when the include parameter is present.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("deductions")
    private Optional<? extends List<Deductions>> deductions;

    /**
     * An array of employer and employee taxes for the pay period. Only included for processed or calculated payrolls when `taxes` is present in the `include` parameter.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("taxes")
    private Optional<? extends List<Taxes>> taxes;

    @JsonCreator
    public PayrollEmployeeCompensationsType(
            @JsonProperty("employee_uuid") Optional<String> employeeUuid,
            @JsonProperty("excluded") Optional<Boolean> excluded,
            @JsonProperty("version") Optional<String> version,
            @JsonProperty("gross_pay") JsonNullable<Double> grossPay,
            @JsonProperty("net_pay") JsonNullable<Double> netPay,
            @JsonProperty("check_amount") JsonNullable<Double> checkAmount,
            @JsonProperty("payment_method") JsonNullable<? extends PayrollEmployeeCompensationsTypePaymentMethod> paymentMethod,
            @JsonProperty("memo") JsonNullable<String> memo,
            @JsonProperty("fixed_compensations") Optional<? extends List<FixedCompensations>> fixedCompensations,
            @JsonProperty("hourly_compensations") Optional<? extends List<HourlyCompensations>> hourlyCompensations,
            @JsonProperty("paid_time_off") Optional<? extends List<PayrollEmployeeCompensationsTypePaidTimeOff>> paidTimeOff,
            @JsonProperty("benefits") Optional<? extends List<Benefits>> benefits,
            @JsonProperty("deductions") Optional<? extends List<Deductions>> deductions,
            @JsonProperty("taxes") Optional<? extends List<Taxes>> taxes) {
        Utils.checkNotNull(employeeUuid, "employeeUuid");
        Utils.checkNotNull(excluded, "excluded");
        Utils.checkNotNull(version, "version");
        Utils.checkNotNull(grossPay, "grossPay");
        Utils.checkNotNull(netPay, "netPay");
        Utils.checkNotNull(checkAmount, "checkAmount");
        Utils.checkNotNull(paymentMethod, "paymentMethod");
        Utils.checkNotNull(memo, "memo");
        Utils.checkNotNull(fixedCompensations, "fixedCompensations");
        Utils.checkNotNull(hourlyCompensations, "hourlyCompensations");
        Utils.checkNotNull(paidTimeOff, "paidTimeOff");
        Utils.checkNotNull(benefits, "benefits");
        Utils.checkNotNull(deductions, "deductions");
        Utils.checkNotNull(taxes, "taxes");
        this.employeeUuid = employeeUuid;
        this.excluded = excluded;
        this.version = version;
        this.grossPay = grossPay;
        this.netPay = netPay;
        this.checkAmount = checkAmount;
        this.paymentMethod = paymentMethod;
        this.memo = memo;
        this.fixedCompensations = fixedCompensations;
        this.hourlyCompensations = hourlyCompensations;
        this.paidTimeOff = paidTimeOff;
        this.benefits = benefits;
        this.deductions = deductions;
        this.taxes = taxes;
    }
    
    public PayrollEmployeeCompensationsType() {
        this(Optional.empty(), Optional.empty(), Optional.empty(), JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty());
    }

    /**
     * The UUID of the employee.
     */
    @JsonIgnore
    public Optional<String> employeeUuid() {
        return employeeUuid;
    }

    /**
     * This employee will be excluded (skipped) from payroll calculation and will not be paid for the payroll. Cancelling a payroll would reset all employees' excluded back to false.
     */
    @JsonIgnore
    public Optional<Boolean> excluded() {
        return excluded;
    }

    /**
     * The current version of this employee compensation. This field is only available for prepared payrolls. See the [versioning guide](https://docs.gusto.com/embedded-payroll/docs/idempotency) for information on how to use this field.
     */
    @JsonIgnore
    public Optional<String> version() {
        return version;
    }

    /**
     * The employee's gross pay, equal to regular wages + cash tips + payroll tips + any other additional earnings, excluding imputed income. This value is only available for processed payrolls.
     */
    @JsonIgnore
    public JsonNullable<Double> grossPay() {
        return grossPay;
    }

    /**
     * The employee's net pay, equal to gross_pay - employee taxes - employee deductions or garnishments - cash tips. This value is only available for processed payrolls.
     */
    @JsonIgnore
    public JsonNullable<Double> netPay() {
        return netPay;
    }

    /**
     * The employee's check amount, equal to net_pay + reimbursements. This value is only available for processed payrolls.
     */
    @JsonIgnore
    public JsonNullable<Double> checkAmount() {
        return checkAmount;
    }

    /**
     * The employee's compensation payment method.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<PayrollEmployeeCompensationsTypePaymentMethod> paymentMethod() {
        return (JsonNullable<PayrollEmployeeCompensationsTypePaymentMethod>) paymentMethod;
    }

    /**
     * Custom text that will be printed as a personal note to the employee on a paystub.
     */
    @JsonIgnore
    public JsonNullable<String> memo() {
        return memo;
    }

    /**
     * An array of fixed compensations for the employee. Fixed compensations include tips, bonuses, and one time reimbursements. If this payroll has been processed, only fixed compensations with a value greater than 0.00 are returned. For an unprocessed payroll, all active fixed compensations are returned.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<FixedCompensations>> fixedCompensations() {
        return (Optional<List<FixedCompensations>>) fixedCompensations;
    }

    /**
     * An array of hourly compensations for the employee. Hourly compensations include regular, overtime, and double overtime hours. If this payroll has been processed, only hourly compensations with a value greater than 0.00 are returned. For an unprocessed payroll, all active hourly compensations are returned.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<HourlyCompensations>> hourlyCompensations() {
        return (Optional<List<HourlyCompensations>>) hourlyCompensations;
    }

    /**
     * An array of all paid time off the employee is eligible for this pay period.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<PayrollEmployeeCompensationsTypePaidTimeOff>> paidTimeOff() {
        return (Optional<List<PayrollEmployeeCompensationsTypePaidTimeOff>>) paidTimeOff;
    }

    /**
     * An array of employee benefits for the pay period. Benefits are only included for processed payroll when the include parameter is present.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<Benefits>> benefits() {
        return (Optional<List<Benefits>>) benefits;
    }

    /**
     * An array of employee deductions for the pay period. Deductions are only included for processed payroll when the include parameter is present.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<Deductions>> deductions() {
        return (Optional<List<Deductions>>) deductions;
    }

    /**
     * An array of employer and employee taxes for the pay period. Only included for processed or calculated payrolls when `taxes` is present in the `include` parameter.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<Taxes>> taxes() {
        return (Optional<List<Taxes>>) taxes;
    }

    public final static Builder builder() {
        return new Builder();
    }

    /**
     * The UUID of the employee.
     */
    public PayrollEmployeeCompensationsType withEmployeeUuid(String employeeUuid) {
        Utils.checkNotNull(employeeUuid, "employeeUuid");
        this.employeeUuid = Optional.ofNullable(employeeUuid);
        return this;
    }

    /**
     * The UUID of the employee.
     */
    public PayrollEmployeeCompensationsType withEmployeeUuid(Optional<String> employeeUuid) {
        Utils.checkNotNull(employeeUuid, "employeeUuid");
        this.employeeUuid = employeeUuid;
        return this;
    }

    /**
     * This employee will be excluded (skipped) from payroll calculation and will not be paid for the payroll. Cancelling a payroll would reset all employees' excluded back to false.
     */
    public PayrollEmployeeCompensationsType withExcluded(boolean excluded) {
        Utils.checkNotNull(excluded, "excluded");
        this.excluded = Optional.ofNullable(excluded);
        return this;
    }

    /**
     * This employee will be excluded (skipped) from payroll calculation and will not be paid for the payroll. Cancelling a payroll would reset all employees' excluded back to false.
     */
    public PayrollEmployeeCompensationsType withExcluded(Optional<Boolean> excluded) {
        Utils.checkNotNull(excluded, "excluded");
        this.excluded = excluded;
        return this;
    }

    /**
     * The current version of this employee compensation. This field is only available for prepared payrolls. See the [versioning guide](https://docs.gusto.com/embedded-payroll/docs/idempotency) for information on how to use this field.
     */
    public PayrollEmployeeCompensationsType withVersion(String version) {
        Utils.checkNotNull(version, "version");
        this.version = Optional.ofNullable(version);
        return this;
    }

    /**
     * The current version of this employee compensation. This field is only available for prepared payrolls. See the [versioning guide](https://docs.gusto.com/embedded-payroll/docs/idempotency) for information on how to use this field.
     */
    public PayrollEmployeeCompensationsType withVersion(Optional<String> version) {
        Utils.checkNotNull(version, "version");
        this.version = version;
        return this;
    }

    /**
     * The employee's gross pay, equal to regular wages + cash tips + payroll tips + any other additional earnings, excluding imputed income. This value is only available for processed payrolls.
     */
    public PayrollEmployeeCompensationsType withGrossPay(double grossPay) {
        Utils.checkNotNull(grossPay, "grossPay");
        this.grossPay = JsonNullable.of(grossPay);
        return this;
    }

    /**
     * The employee's gross pay, equal to regular wages + cash tips + payroll tips + any other additional earnings, excluding imputed income. This value is only available for processed payrolls.
     */
    public PayrollEmployeeCompensationsType withGrossPay(JsonNullable<Double> grossPay) {
        Utils.checkNotNull(grossPay, "grossPay");
        this.grossPay = grossPay;
        return this;
    }

    /**
     * The employee's net pay, equal to gross_pay - employee taxes - employee deductions or garnishments - cash tips. This value is only available for processed payrolls.
     */
    public PayrollEmployeeCompensationsType withNetPay(double netPay) {
        Utils.checkNotNull(netPay, "netPay");
        this.netPay = JsonNullable.of(netPay);
        return this;
    }

    /**
     * The employee's net pay, equal to gross_pay - employee taxes - employee deductions or garnishments - cash tips. This value is only available for processed payrolls.
     */
    public PayrollEmployeeCompensationsType withNetPay(JsonNullable<Double> netPay) {
        Utils.checkNotNull(netPay, "netPay");
        this.netPay = netPay;
        return this;
    }

    /**
     * The employee's check amount, equal to net_pay + reimbursements. This value is only available for processed payrolls.
     */
    public PayrollEmployeeCompensationsType withCheckAmount(double checkAmount) {
        Utils.checkNotNull(checkAmount, "checkAmount");
        this.checkAmount = JsonNullable.of(checkAmount);
        return this;
    }

    /**
     * The employee's check amount, equal to net_pay + reimbursements. This value is only available for processed payrolls.
     */
    public PayrollEmployeeCompensationsType withCheckAmount(JsonNullable<Double> checkAmount) {
        Utils.checkNotNull(checkAmount, "checkAmount");
        this.checkAmount = checkAmount;
        return this;
    }

    /**
     * The employee's compensation payment method.
     */
    public PayrollEmployeeCompensationsType withPaymentMethod(PayrollEmployeeCompensationsTypePaymentMethod paymentMethod) {
        Utils.checkNotNull(paymentMethod, "paymentMethod");
        this.paymentMethod = JsonNullable.of(paymentMethod);
        return this;
    }

    /**
     * The employee's compensation payment method.
     */
    public PayrollEmployeeCompensationsType withPaymentMethod(JsonNullable<? extends PayrollEmployeeCompensationsTypePaymentMethod> paymentMethod) {
        Utils.checkNotNull(paymentMethod, "paymentMethod");
        this.paymentMethod = paymentMethod;
        return this;
    }

    /**
     * Custom text that will be printed as a personal note to the employee on a paystub.
     */
    public PayrollEmployeeCompensationsType withMemo(String memo) {
        Utils.checkNotNull(memo, "memo");
        this.memo = JsonNullable.of(memo);
        return this;
    }

    /**
     * Custom text that will be printed as a personal note to the employee on a paystub.
     */
    public PayrollEmployeeCompensationsType withMemo(JsonNullable<String> memo) {
        Utils.checkNotNull(memo, "memo");
        this.memo = memo;
        return this;
    }

    /**
     * An array of fixed compensations for the employee. Fixed compensations include tips, bonuses, and one time reimbursements. If this payroll has been processed, only fixed compensations with a value greater than 0.00 are returned. For an unprocessed payroll, all active fixed compensations are returned.
     */
    public PayrollEmployeeCompensationsType withFixedCompensations(List<FixedCompensations> fixedCompensations) {
        Utils.checkNotNull(fixedCompensations, "fixedCompensations");
        this.fixedCompensations = Optional.ofNullable(fixedCompensations);
        return this;
    }

    /**
     * An array of fixed compensations for the employee. Fixed compensations include tips, bonuses, and one time reimbursements. If this payroll has been processed, only fixed compensations with a value greater than 0.00 are returned. For an unprocessed payroll, all active fixed compensations are returned.
     */
    public PayrollEmployeeCompensationsType withFixedCompensations(Optional<? extends List<FixedCompensations>> fixedCompensations) {
        Utils.checkNotNull(fixedCompensations, "fixedCompensations");
        this.fixedCompensations = fixedCompensations;
        return this;
    }

    /**
     * An array of hourly compensations for the employee. Hourly compensations include regular, overtime, and double overtime hours. If this payroll has been processed, only hourly compensations with a value greater than 0.00 are returned. For an unprocessed payroll, all active hourly compensations are returned.
     */
    public PayrollEmployeeCompensationsType withHourlyCompensations(List<HourlyCompensations> hourlyCompensations) {
        Utils.checkNotNull(hourlyCompensations, "hourlyCompensations");
        this.hourlyCompensations = Optional.ofNullable(hourlyCompensations);
        return this;
    }

    /**
     * An array of hourly compensations for the employee. Hourly compensations include regular, overtime, and double overtime hours. If this payroll has been processed, only hourly compensations with a value greater than 0.00 are returned. For an unprocessed payroll, all active hourly compensations are returned.
     */
    public PayrollEmployeeCompensationsType withHourlyCompensations(Optional<? extends List<HourlyCompensations>> hourlyCompensations) {
        Utils.checkNotNull(hourlyCompensations, "hourlyCompensations");
        this.hourlyCompensations = hourlyCompensations;
        return this;
    }

    /**
     * An array of all paid time off the employee is eligible for this pay period.
     */
    public PayrollEmployeeCompensationsType withPaidTimeOff(List<PayrollEmployeeCompensationsTypePaidTimeOff> paidTimeOff) {
        Utils.checkNotNull(paidTimeOff, "paidTimeOff");
        this.paidTimeOff = Optional.ofNullable(paidTimeOff);
        return this;
    }

    /**
     * An array of all paid time off the employee is eligible for this pay period.
     */
    public PayrollEmployeeCompensationsType withPaidTimeOff(Optional<? extends List<PayrollEmployeeCompensationsTypePaidTimeOff>> paidTimeOff) {
        Utils.checkNotNull(paidTimeOff, "paidTimeOff");
        this.paidTimeOff = paidTimeOff;
        return this;
    }

    /**
     * An array of employee benefits for the pay period. Benefits are only included for processed payroll when the include parameter is present.
     */
    public PayrollEmployeeCompensationsType withBenefits(List<Benefits> benefits) {
        Utils.checkNotNull(benefits, "benefits");
        this.benefits = Optional.ofNullable(benefits);
        return this;
    }

    /**
     * An array of employee benefits for the pay period. Benefits are only included for processed payroll when the include parameter is present.
     */
    public PayrollEmployeeCompensationsType withBenefits(Optional<? extends List<Benefits>> benefits) {
        Utils.checkNotNull(benefits, "benefits");
        this.benefits = benefits;
        return this;
    }

    /**
     * An array of employee deductions for the pay period. Deductions are only included for processed payroll when the include parameter is present.
     */
    public PayrollEmployeeCompensationsType withDeductions(List<Deductions> deductions) {
        Utils.checkNotNull(deductions, "deductions");
        this.deductions = Optional.ofNullable(deductions);
        return this;
    }

    /**
     * An array of employee deductions for the pay period. Deductions are only included for processed payroll when the include parameter is present.
     */
    public PayrollEmployeeCompensationsType withDeductions(Optional<? extends List<Deductions>> deductions) {
        Utils.checkNotNull(deductions, "deductions");
        this.deductions = deductions;
        return this;
    }

    /**
     * An array of employer and employee taxes for the pay period. Only included for processed or calculated payrolls when `taxes` is present in the `include` parameter.
     */
    public PayrollEmployeeCompensationsType withTaxes(List<Taxes> taxes) {
        Utils.checkNotNull(taxes, "taxes");
        this.taxes = Optional.ofNullable(taxes);
        return this;
    }

    /**
     * An array of employer and employee taxes for the pay period. Only included for processed or calculated payrolls when `taxes` is present in the `include` parameter.
     */
    public PayrollEmployeeCompensationsType withTaxes(Optional<? extends List<Taxes>> taxes) {
        Utils.checkNotNull(taxes, "taxes");
        this.taxes = taxes;
        return this;
    }
    
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        PayrollEmployeeCompensationsType other = (PayrollEmployeeCompensationsType) o;
        return 
            Objects.deepEquals(this.employeeUuid, other.employeeUuid) &&
            Objects.deepEquals(this.excluded, other.excluded) &&
            Objects.deepEquals(this.version, other.version) &&
            Objects.deepEquals(this.grossPay, other.grossPay) &&
            Objects.deepEquals(this.netPay, other.netPay) &&
            Objects.deepEquals(this.checkAmount, other.checkAmount) &&
            Objects.deepEquals(this.paymentMethod, other.paymentMethod) &&
            Objects.deepEquals(this.memo, other.memo) &&
            Objects.deepEquals(this.fixedCompensations, other.fixedCompensations) &&
            Objects.deepEquals(this.hourlyCompensations, other.hourlyCompensations) &&
            Objects.deepEquals(this.paidTimeOff, other.paidTimeOff) &&
            Objects.deepEquals(this.benefits, other.benefits) &&
            Objects.deepEquals(this.deductions, other.deductions) &&
            Objects.deepEquals(this.taxes, other.taxes);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(
            employeeUuid,
            excluded,
            version,
            grossPay,
            netPay,
            checkAmount,
            paymentMethod,
            memo,
            fixedCompensations,
            hourlyCompensations,
            paidTimeOff,
            benefits,
            deductions,
            taxes);
    }
    
    @Override
    public String toString() {
        return Utils.toString(PayrollEmployeeCompensationsType.class,
                "employeeUuid", employeeUuid,
                "excluded", excluded,
                "version", version,
                "grossPay", grossPay,
                "netPay", netPay,
                "checkAmount", checkAmount,
                "paymentMethod", paymentMethod,
                "memo", memo,
                "fixedCompensations", fixedCompensations,
                "hourlyCompensations", hourlyCompensations,
                "paidTimeOff", paidTimeOff,
                "benefits", benefits,
                "deductions", deductions,
                "taxes", taxes);
    }
    
    public final static class Builder {
 
        private Optional<String> employeeUuid = Optional.empty();
 
        private Optional<Boolean> excluded = Optional.empty();
 
        private Optional<String> version = Optional.empty();
 
        private JsonNullable<Double> grossPay = JsonNullable.undefined();
 
        private JsonNullable<Double> netPay = JsonNullable.undefined();
 
        private JsonNullable<Double> checkAmount = JsonNullable.undefined();
 
        private JsonNullable<? extends PayrollEmployeeCompensationsTypePaymentMethod> paymentMethod = JsonNullable.undefined();
 
        private JsonNullable<String> memo = JsonNullable.undefined();
 
        private Optional<? extends List<FixedCompensations>> fixedCompensations = Optional.empty();
 
        private Optional<? extends List<HourlyCompensations>> hourlyCompensations = Optional.empty();
 
        private Optional<? extends List<PayrollEmployeeCompensationsTypePaidTimeOff>> paidTimeOff = Optional.empty();
 
        private Optional<? extends List<Benefits>> benefits = Optional.empty();
 
        private Optional<? extends List<Deductions>> deductions = Optional.empty();
 
        private Optional<? extends List<Taxes>> taxes = Optional.empty();  
        
        private Builder() {
          // force use of static builder() method
        }

        /**
         * The UUID of the employee.
         */
        public Builder employeeUuid(String employeeUuid) {
            Utils.checkNotNull(employeeUuid, "employeeUuid");
            this.employeeUuid = Optional.ofNullable(employeeUuid);
            return this;
        }

        /**
         * The UUID of the employee.
         */
        public Builder employeeUuid(Optional<String> employeeUuid) {
            Utils.checkNotNull(employeeUuid, "employeeUuid");
            this.employeeUuid = employeeUuid;
            return this;
        }

        /**
         * This employee will be excluded (skipped) from payroll calculation and will not be paid for the payroll. Cancelling a payroll would reset all employees' excluded back to false.
         */
        public Builder excluded(boolean excluded) {
            Utils.checkNotNull(excluded, "excluded");
            this.excluded = Optional.ofNullable(excluded);
            return this;
        }

        /**
         * This employee will be excluded (skipped) from payroll calculation and will not be paid for the payroll. Cancelling a payroll would reset all employees' excluded back to false.
         */
        public Builder excluded(Optional<Boolean> excluded) {
            Utils.checkNotNull(excluded, "excluded");
            this.excluded = excluded;
            return this;
        }

        /**
         * The current version of this employee compensation. This field is only available for prepared payrolls. See the [versioning guide](https://docs.gusto.com/embedded-payroll/docs/idempotency) for information on how to use this field.
         */
        public Builder version(String version) {
            Utils.checkNotNull(version, "version");
            this.version = Optional.ofNullable(version);
            return this;
        }

        /**
         * The current version of this employee compensation. This field is only available for prepared payrolls. See the [versioning guide](https://docs.gusto.com/embedded-payroll/docs/idempotency) for information on how to use this field.
         */
        public Builder version(Optional<String> version) {
            Utils.checkNotNull(version, "version");
            this.version = version;
            return this;
        }

        /**
         * The employee's gross pay, equal to regular wages + cash tips + payroll tips + any other additional earnings, excluding imputed income. This value is only available for processed payrolls.
         */
        public Builder grossPay(double grossPay) {
            Utils.checkNotNull(grossPay, "grossPay");
            this.grossPay = JsonNullable.of(grossPay);
            return this;
        }

        /**
         * The employee's gross pay, equal to regular wages + cash tips + payroll tips + any other additional earnings, excluding imputed income. This value is only available for processed payrolls.
         */
        public Builder grossPay(JsonNullable<Double> grossPay) {
            Utils.checkNotNull(grossPay, "grossPay");
            this.grossPay = grossPay;
            return this;
        }

        /**
         * The employee's net pay, equal to gross_pay - employee taxes - employee deductions or garnishments - cash tips. This value is only available for processed payrolls.
         */
        public Builder netPay(double netPay) {
            Utils.checkNotNull(netPay, "netPay");
            this.netPay = JsonNullable.of(netPay);
            return this;
        }

        /**
         * The employee's net pay, equal to gross_pay - employee taxes - employee deductions or garnishments - cash tips. This value is only available for processed payrolls.
         */
        public Builder netPay(JsonNullable<Double> netPay) {
            Utils.checkNotNull(netPay, "netPay");
            this.netPay = netPay;
            return this;
        }

        /**
         * The employee's check amount, equal to net_pay + reimbursements. This value is only available for processed payrolls.
         */
        public Builder checkAmount(double checkAmount) {
            Utils.checkNotNull(checkAmount, "checkAmount");
            this.checkAmount = JsonNullable.of(checkAmount);
            return this;
        }

        /**
         * The employee's check amount, equal to net_pay + reimbursements. This value is only available for processed payrolls.
         */
        public Builder checkAmount(JsonNullable<Double> checkAmount) {
            Utils.checkNotNull(checkAmount, "checkAmount");
            this.checkAmount = checkAmount;
            return this;
        }

        /**
         * The employee's compensation payment method.
         */
        public Builder paymentMethod(PayrollEmployeeCompensationsTypePaymentMethod paymentMethod) {
            Utils.checkNotNull(paymentMethod, "paymentMethod");
            this.paymentMethod = JsonNullable.of(paymentMethod);
            return this;
        }

        /**
         * The employee's compensation payment method.
         */
        public Builder paymentMethod(JsonNullable<? extends PayrollEmployeeCompensationsTypePaymentMethod> paymentMethod) {
            Utils.checkNotNull(paymentMethod, "paymentMethod");
            this.paymentMethod = paymentMethod;
            return this;
        }

        /**
         * Custom text that will be printed as a personal note to the employee on a paystub.
         */
        public Builder memo(String memo) {
            Utils.checkNotNull(memo, "memo");
            this.memo = JsonNullable.of(memo);
            return this;
        }

        /**
         * Custom text that will be printed as a personal note to the employee on a paystub.
         */
        public Builder memo(JsonNullable<String> memo) {
            Utils.checkNotNull(memo, "memo");
            this.memo = memo;
            return this;
        }

        /**
         * An array of fixed compensations for the employee. Fixed compensations include tips, bonuses, and one time reimbursements. If this payroll has been processed, only fixed compensations with a value greater than 0.00 are returned. For an unprocessed payroll, all active fixed compensations are returned.
         */
        public Builder fixedCompensations(List<FixedCompensations> fixedCompensations) {
            Utils.checkNotNull(fixedCompensations, "fixedCompensations");
            this.fixedCompensations = Optional.ofNullable(fixedCompensations);
            return this;
        }

        /**
         * An array of fixed compensations for the employee. Fixed compensations include tips, bonuses, and one time reimbursements. If this payroll has been processed, only fixed compensations with a value greater than 0.00 are returned. For an unprocessed payroll, all active fixed compensations are returned.
         */
        public Builder fixedCompensations(Optional<? extends List<FixedCompensations>> fixedCompensations) {
            Utils.checkNotNull(fixedCompensations, "fixedCompensations");
            this.fixedCompensations = fixedCompensations;
            return this;
        }

        /**
         * An array of hourly compensations for the employee. Hourly compensations include regular, overtime, and double overtime hours. If this payroll has been processed, only hourly compensations with a value greater than 0.00 are returned. For an unprocessed payroll, all active hourly compensations are returned.
         */
        public Builder hourlyCompensations(List<HourlyCompensations> hourlyCompensations) {
            Utils.checkNotNull(hourlyCompensations, "hourlyCompensations");
            this.hourlyCompensations = Optional.ofNullable(hourlyCompensations);
            return this;
        }

        /**
         * An array of hourly compensations for the employee. Hourly compensations include regular, overtime, and double overtime hours. If this payroll has been processed, only hourly compensations with a value greater than 0.00 are returned. For an unprocessed payroll, all active hourly compensations are returned.
         */
        public Builder hourlyCompensations(Optional<? extends List<HourlyCompensations>> hourlyCompensations) {
            Utils.checkNotNull(hourlyCompensations, "hourlyCompensations");
            this.hourlyCompensations = hourlyCompensations;
            return this;
        }

        /**
         * An array of all paid time off the employee is eligible for this pay period.
         */
        public Builder paidTimeOff(List<PayrollEmployeeCompensationsTypePaidTimeOff> paidTimeOff) {
            Utils.checkNotNull(paidTimeOff, "paidTimeOff");
            this.paidTimeOff = Optional.ofNullable(paidTimeOff);
            return this;
        }

        /**
         * An array of all paid time off the employee is eligible for this pay period.
         */
        public Builder paidTimeOff(Optional<? extends List<PayrollEmployeeCompensationsTypePaidTimeOff>> paidTimeOff) {
            Utils.checkNotNull(paidTimeOff, "paidTimeOff");
            this.paidTimeOff = paidTimeOff;
            return this;
        }

        /**
         * An array of employee benefits for the pay period. Benefits are only included for processed payroll when the include parameter is present.
         */
        public Builder benefits(List<Benefits> benefits) {
            Utils.checkNotNull(benefits, "benefits");
            this.benefits = Optional.ofNullable(benefits);
            return this;
        }

        /**
         * An array of employee benefits for the pay period. Benefits are only included for processed payroll when the include parameter is present.
         */
        public Builder benefits(Optional<? extends List<Benefits>> benefits) {
            Utils.checkNotNull(benefits, "benefits");
            this.benefits = benefits;
            return this;
        }

        /**
         * An array of employee deductions for the pay period. Deductions are only included for processed payroll when the include parameter is present.
         */
        public Builder deductions(List<Deductions> deductions) {
            Utils.checkNotNull(deductions, "deductions");
            this.deductions = Optional.ofNullable(deductions);
            return this;
        }

        /**
         * An array of employee deductions for the pay period. Deductions are only included for processed payroll when the include parameter is present.
         */
        public Builder deductions(Optional<? extends List<Deductions>> deductions) {
            Utils.checkNotNull(deductions, "deductions");
            this.deductions = deductions;
            return this;
        }

        /**
         * An array of employer and employee taxes for the pay period. Only included for processed or calculated payrolls when `taxes` is present in the `include` parameter.
         */
        public Builder taxes(List<Taxes> taxes) {
            Utils.checkNotNull(taxes, "taxes");
            this.taxes = Optional.ofNullable(taxes);
            return this;
        }

        /**
         * An array of employer and employee taxes for the pay period. Only included for processed or calculated payrolls when `taxes` is present in the `include` parameter.
         */
        public Builder taxes(Optional<? extends List<Taxes>> taxes) {
            Utils.checkNotNull(taxes, "taxes");
            this.taxes = taxes;
            return this;
        }
        
        public PayrollEmployeeCompensationsType build() {
            return new PayrollEmployeeCompensationsType(
                employeeUuid,
                excluded,
                version,
                grossPay,
                netPay,
                checkAmount,
                paymentMethod,
                memo,
                fixedCompensations,
                hourlyCompensations,
                paidTimeOff,
                benefits,
                deductions,
                taxes);
        }
    }
}

