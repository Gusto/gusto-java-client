/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

package com.gusto.embedded_api.models.components;


import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.gusto.embedded_api.utils.Utils;
import java.lang.Override;
import java.lang.String;
import java.lang.SuppressWarnings;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import org.openapitools.jackson.nullable.JsonNullable;

/**
 * EmployeePaymentMethod - Example response
 */

public class EmployeePaymentMethod {

    /**
     * The current version of the object. See the [versioning guide](https://docs.gusto.com/embedded-payroll/docs/idempotency) for information on how to use this field.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("version")
    private Optional<String> version;

    /**
     * The payment method type. If type is Check, then split_by and splits do not need to be populated. If type is Direct Deposit, split_by and splits are required.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("type")
    private Optional<? extends EmployeePaymentMethodType> type;

    /**
     * Describes how the payment will be split. If split_by is Percentage, then the split amounts must add up to exactly 100. If split_by is Amount, then the last split amount must be nil to capture the remainder.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("split_by")
    private JsonNullable<? extends SplitBy> splitBy;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("splits")
    private JsonNullable<? extends List<PaymentMethodBankAccount>> splits;

    @JsonCreator
    public EmployeePaymentMethod(
            @JsonProperty("version") Optional<String> version,
            @JsonProperty("type") Optional<? extends EmployeePaymentMethodType> type,
            @JsonProperty("split_by") JsonNullable<? extends SplitBy> splitBy,
            @JsonProperty("splits") JsonNullable<? extends List<PaymentMethodBankAccount>> splits) {
        Utils.checkNotNull(version, "version");
        Utils.checkNotNull(type, "type");
        Utils.checkNotNull(splitBy, "splitBy");
        Utils.checkNotNull(splits, "splits");
        this.version = version;
        this.type = type;
        this.splitBy = splitBy;
        this.splits = splits;
    }
    
    public EmployeePaymentMethod() {
        this(Optional.empty(), Optional.empty(), JsonNullable.undefined(), JsonNullable.undefined());
    }

    /**
     * The current version of the object. See the [versioning guide](https://docs.gusto.com/embedded-payroll/docs/idempotency) for information on how to use this field.
     */
    @JsonIgnore
    public Optional<String> version() {
        return version;
    }

    /**
     * The payment method type. If type is Check, then split_by and splits do not need to be populated. If type is Direct Deposit, split_by and splits are required.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<EmployeePaymentMethodType> type() {
        return (Optional<EmployeePaymentMethodType>) type;
    }

    /**
     * Describes how the payment will be split. If split_by is Percentage, then the split amounts must add up to exactly 100. If split_by is Amount, then the last split amount must be nil to capture the remainder.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<SplitBy> splitBy() {
        return (JsonNullable<SplitBy>) splitBy;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<List<PaymentMethodBankAccount>> splits() {
        return (JsonNullable<List<PaymentMethodBankAccount>>) splits;
    }

    public final static Builder builder() {
        return new Builder();
    }

    /**
     * The current version of the object. See the [versioning guide](https://docs.gusto.com/embedded-payroll/docs/idempotency) for information on how to use this field.
     */
    public EmployeePaymentMethod withVersion(String version) {
        Utils.checkNotNull(version, "version");
        this.version = Optional.ofNullable(version);
        return this;
    }

    /**
     * The current version of the object. See the [versioning guide](https://docs.gusto.com/embedded-payroll/docs/idempotency) for information on how to use this field.
     */
    public EmployeePaymentMethod withVersion(Optional<String> version) {
        Utils.checkNotNull(version, "version");
        this.version = version;
        return this;
    }

    /**
     * The payment method type. If type is Check, then split_by and splits do not need to be populated. If type is Direct Deposit, split_by and splits are required.
     */
    public EmployeePaymentMethod withType(EmployeePaymentMethodType type) {
        Utils.checkNotNull(type, "type");
        this.type = Optional.ofNullable(type);
        return this;
    }

    /**
     * The payment method type. If type is Check, then split_by and splits do not need to be populated. If type is Direct Deposit, split_by and splits are required.
     */
    public EmployeePaymentMethod withType(Optional<? extends EmployeePaymentMethodType> type) {
        Utils.checkNotNull(type, "type");
        this.type = type;
        return this;
    }

    /**
     * Describes how the payment will be split. If split_by is Percentage, then the split amounts must add up to exactly 100. If split_by is Amount, then the last split amount must be nil to capture the remainder.
     */
    public EmployeePaymentMethod withSplitBy(SplitBy splitBy) {
        Utils.checkNotNull(splitBy, "splitBy");
        this.splitBy = JsonNullable.of(splitBy);
        return this;
    }

    /**
     * Describes how the payment will be split. If split_by is Percentage, then the split amounts must add up to exactly 100. If split_by is Amount, then the last split amount must be nil to capture the remainder.
     */
    public EmployeePaymentMethod withSplitBy(JsonNullable<? extends SplitBy> splitBy) {
        Utils.checkNotNull(splitBy, "splitBy");
        this.splitBy = splitBy;
        return this;
    }

    public EmployeePaymentMethod withSplits(List<PaymentMethodBankAccount> splits) {
        Utils.checkNotNull(splits, "splits");
        this.splits = JsonNullable.of(splits);
        return this;
    }

    public EmployeePaymentMethod withSplits(JsonNullable<? extends List<PaymentMethodBankAccount>> splits) {
        Utils.checkNotNull(splits, "splits");
        this.splits = splits;
        return this;
    }
    
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        EmployeePaymentMethod other = (EmployeePaymentMethod) o;
        return 
            Objects.deepEquals(this.version, other.version) &&
            Objects.deepEquals(this.type, other.type) &&
            Objects.deepEquals(this.splitBy, other.splitBy) &&
            Objects.deepEquals(this.splits, other.splits);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(
            version,
            type,
            splitBy,
            splits);
    }
    
    @Override
    public String toString() {
        return Utils.toString(EmployeePaymentMethod.class,
                "version", version,
                "type", type,
                "splitBy", splitBy,
                "splits", splits);
    }
    
    public final static class Builder {
 
        private Optional<String> version = Optional.empty();
 
        private Optional<? extends EmployeePaymentMethodType> type = Optional.empty();
 
        private JsonNullable<? extends SplitBy> splitBy = JsonNullable.undefined();
 
        private JsonNullable<? extends List<PaymentMethodBankAccount>> splits = JsonNullable.undefined();  
        
        private Builder() {
          // force use of static builder() method
        }

        /**
         * The current version of the object. See the [versioning guide](https://docs.gusto.com/embedded-payroll/docs/idempotency) for information on how to use this field.
         */
        public Builder version(String version) {
            Utils.checkNotNull(version, "version");
            this.version = Optional.ofNullable(version);
            return this;
        }

        /**
         * The current version of the object. See the [versioning guide](https://docs.gusto.com/embedded-payroll/docs/idempotency) for information on how to use this field.
         */
        public Builder version(Optional<String> version) {
            Utils.checkNotNull(version, "version");
            this.version = version;
            return this;
        }

        /**
         * The payment method type. If type is Check, then split_by and splits do not need to be populated. If type is Direct Deposit, split_by and splits are required.
         */
        public Builder type(EmployeePaymentMethodType type) {
            Utils.checkNotNull(type, "type");
            this.type = Optional.ofNullable(type);
            return this;
        }

        /**
         * The payment method type. If type is Check, then split_by and splits do not need to be populated. If type is Direct Deposit, split_by and splits are required.
         */
        public Builder type(Optional<? extends EmployeePaymentMethodType> type) {
            Utils.checkNotNull(type, "type");
            this.type = type;
            return this;
        }

        /**
         * Describes how the payment will be split. If split_by is Percentage, then the split amounts must add up to exactly 100. If split_by is Amount, then the last split amount must be nil to capture the remainder.
         */
        public Builder splitBy(SplitBy splitBy) {
            Utils.checkNotNull(splitBy, "splitBy");
            this.splitBy = JsonNullable.of(splitBy);
            return this;
        }

        /**
         * Describes how the payment will be split. If split_by is Percentage, then the split amounts must add up to exactly 100. If split_by is Amount, then the last split amount must be nil to capture the remainder.
         */
        public Builder splitBy(JsonNullable<? extends SplitBy> splitBy) {
            Utils.checkNotNull(splitBy, "splitBy");
            this.splitBy = splitBy;
            return this;
        }

        public Builder splits(List<PaymentMethodBankAccount> splits) {
            Utils.checkNotNull(splits, "splits");
            this.splits = JsonNullable.of(splits);
            return this;
        }

        public Builder splits(JsonNullable<? extends List<PaymentMethodBankAccount>> splits) {
            Utils.checkNotNull(splits, "splits");
            this.splits = splits;
            return this;
        }
        
        public EmployeePaymentMethod build() {
            return new EmployeePaymentMethod(
                version,
                type,
                splitBy,
                splits);
        }
    }
}

