/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */


package com.gusto.embedded_api.models.components;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.gusto.embedded_api.utils.Utils;
import java.lang.Boolean;
import java.lang.Override;
import java.lang.String;
import java.lang.SuppressWarnings;
import java.time.OffsetDateTime;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import org.openapitools.jackson.nullable.JsonNullable;
/**
 * PayrollMinimal
 * 
 * <p>Example response
 */

public class PayrollMinimal {

    /**
     * A timestamp that is the deadline for the payroll to be run in order for employees to be paid on time.  If payroll has not been run by the deadline, a prepare request will update both the check date and deadline to reflect the soonest employees can be paid and the deadline by which the payroll must be run in order for said check date to be met.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("payroll_deadline")
    private Optional<OffsetDateTime> payrollDeadline;

    /**
     * The date on which employees will be paid for the payroll.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("check_date")
    private Optional<String> checkDate;

    /**
     * Whether or not the payroll has been successfully processed. Note that processed payrolls cannot be updated. Additionally, a payroll is not guaranteed to be processed just because the payroll deadline has passed. Late payrolls are not uncommon. Conversely, users may choose to run payroll before the payroll deadline.
     */
    @JsonProperty("processed")
    private boolean processed;

    /**
     * The date at which the payroll was processed. Null if the payroll isn't processed yet.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("processed_date")
    private Optional<String> processedDate;

    /**
     * A timestamp of the last valid payroll calculation. Null if there isn't a valid calculation.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("calculated_at")
    private Optional<String> calculatedAt;

    /**
     * The UUID of the payroll.
     */
    @JsonProperty("uuid")
    private String uuid;

    /**
     * The UUID of the payroll.
     */
    @JsonProperty("payroll_uuid")
    private String payrollUuid;

    /**
     * The UUID of the company for the payroll.
     */
    @JsonProperty("company_uuid")
    private String companyUuid;

    /**
     * Indicates whether the payroll is an off-cycle payroll
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("off_cycle")
    private Optional<Boolean> offCycle;

    /**
     * The off-cycle reason. Only included for off-cycle payrolls.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("off_cycle_reason")
    private JsonNullable<? extends OffCycleReasonType> offCycleReason;

    /**
     * Indicates whether the payroll is an auto pilot payroll
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("auto_pilot")
    private Optional<Boolean> autoPilot;

    /**
     * Indicates whether the payroll is an external payroll
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("external")
    private Optional<Boolean> external;

    /**
     * Indicates whether the payroll is the final payroll for a terminated employee. Only included for off-cycle payrolls.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("final_termination_payroll")
    private Optional<Boolean> finalTerminationPayroll;

    /**
     * The payment schedule tax rate the payroll is based on. Only included for off-cycle payrolls.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("withholding_pay_period")
    private Optional<? extends PayrollWithholdingPayPeriodType> withholdingPayPeriod;

    /**
     * Block regular deductions and contributions for this payroll.  Only included for off-cycle payrolls.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("skip_regular_deductions")
    private Optional<Boolean> skipRegularDeductions;

    /**
     * Enable taxes to be withheld at the IRS's required rate of 22% for federal income taxes. State income taxes will be taxed at the state's supplemental tax rate. Otherwise, we'll sum the entirety of the employee's wages and withhold taxes on the entire amount at the rate for regular wages. Only included for off-cycle payrolls.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("fixed_withholding_rate")
    private Optional<Boolean> fixedWithholdingRate;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("pay_period")
    private Optional<? extends PayrollPayPeriodType> payPeriod;

    /**
     * Information about the payroll's status and expected dates
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("payroll_status_meta")
    private Optional<? extends PayrollPayrollStatusMetaType> payrollStatusMeta;

    /**
     * The subtotals for the payroll.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("totals")
    private Optional<? extends PayrollTotalsType> totals;

    /**
     * Only applicable when a payroll is moved to four day processing instead of fast ach.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("payment_speed_changed")
    private Optional<? extends PayrollPaymentSpeedChangedType> paymentSpeedChanged;

    /**
     * Datetime for when the resource was created.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("created_at")
    private Optional<OffsetDateTime> createdAt;

    /**
     * Only included for processed or calculated payrolls
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("submission_blockers")
    private Optional<? extends List<PayrollSubmissionBlockersType>> submissionBlockers;

    /**
     * Only included for processed payrolls
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("credit_blockers")
    private Optional<? extends List<PayrollCreditBlockersType>> creditBlockers;

    @JsonCreator
    public PayrollMinimal(
            @JsonProperty("payroll_deadline") Optional<OffsetDateTime> payrollDeadline,
            @JsonProperty("check_date") Optional<String> checkDate,
            @JsonProperty("processed") boolean processed,
            @JsonProperty("processed_date") Optional<String> processedDate,
            @JsonProperty("calculated_at") Optional<String> calculatedAt,
            @JsonProperty("uuid") String uuid,
            @JsonProperty("payroll_uuid") String payrollUuid,
            @JsonProperty("company_uuid") String companyUuid,
            @JsonProperty("off_cycle") Optional<Boolean> offCycle,
            @JsonProperty("off_cycle_reason") JsonNullable<? extends OffCycleReasonType> offCycleReason,
            @JsonProperty("auto_pilot") Optional<Boolean> autoPilot,
            @JsonProperty("external") Optional<Boolean> external,
            @JsonProperty("final_termination_payroll") Optional<Boolean> finalTerminationPayroll,
            @JsonProperty("withholding_pay_period") Optional<? extends PayrollWithholdingPayPeriodType> withholdingPayPeriod,
            @JsonProperty("skip_regular_deductions") Optional<Boolean> skipRegularDeductions,
            @JsonProperty("fixed_withholding_rate") Optional<Boolean> fixedWithholdingRate,
            @JsonProperty("pay_period") Optional<? extends PayrollPayPeriodType> payPeriod,
            @JsonProperty("payroll_status_meta") Optional<? extends PayrollPayrollStatusMetaType> payrollStatusMeta,
            @JsonProperty("totals") Optional<? extends PayrollTotalsType> totals,
            @JsonProperty("payment_speed_changed") Optional<? extends PayrollPaymentSpeedChangedType> paymentSpeedChanged,
            @JsonProperty("created_at") Optional<OffsetDateTime> createdAt,
            @JsonProperty("submission_blockers") Optional<? extends List<PayrollSubmissionBlockersType>> submissionBlockers,
            @JsonProperty("credit_blockers") Optional<? extends List<PayrollCreditBlockersType>> creditBlockers) {
        Utils.checkNotNull(payrollDeadline, "payrollDeadline");
        Utils.checkNotNull(checkDate, "checkDate");
        Utils.checkNotNull(processed, "processed");
        Utils.checkNotNull(processedDate, "processedDate");
        Utils.checkNotNull(calculatedAt, "calculatedAt");
        Utils.checkNotNull(uuid, "uuid");
        Utils.checkNotNull(payrollUuid, "payrollUuid");
        Utils.checkNotNull(companyUuid, "companyUuid");
        Utils.checkNotNull(offCycle, "offCycle");
        Utils.checkNotNull(offCycleReason, "offCycleReason");
        Utils.checkNotNull(autoPilot, "autoPilot");
        Utils.checkNotNull(external, "external");
        Utils.checkNotNull(finalTerminationPayroll, "finalTerminationPayroll");
        Utils.checkNotNull(withholdingPayPeriod, "withholdingPayPeriod");
        Utils.checkNotNull(skipRegularDeductions, "skipRegularDeductions");
        Utils.checkNotNull(fixedWithholdingRate, "fixedWithholdingRate");
        Utils.checkNotNull(payPeriod, "payPeriod");
        Utils.checkNotNull(payrollStatusMeta, "payrollStatusMeta");
        Utils.checkNotNull(totals, "totals");
        Utils.checkNotNull(paymentSpeedChanged, "paymentSpeedChanged");
        Utils.checkNotNull(createdAt, "createdAt");
        Utils.checkNotNull(submissionBlockers, "submissionBlockers");
        Utils.checkNotNull(creditBlockers, "creditBlockers");
        this.payrollDeadline = payrollDeadline;
        this.checkDate = checkDate;
        this.processed = processed;
        this.processedDate = processedDate;
        this.calculatedAt = calculatedAt;
        this.uuid = uuid;
        this.payrollUuid = payrollUuid;
        this.companyUuid = companyUuid;
        this.offCycle = offCycle;
        this.offCycleReason = offCycleReason;
        this.autoPilot = autoPilot;
        this.external = external;
        this.finalTerminationPayroll = finalTerminationPayroll;
        this.withholdingPayPeriod = withholdingPayPeriod;
        this.skipRegularDeductions = skipRegularDeductions;
        this.fixedWithholdingRate = fixedWithholdingRate;
        this.payPeriod = payPeriod;
        this.payrollStatusMeta = payrollStatusMeta;
        this.totals = totals;
        this.paymentSpeedChanged = paymentSpeedChanged;
        this.createdAt = createdAt;
        this.submissionBlockers = submissionBlockers;
        this.creditBlockers = creditBlockers;
    }
    
    public PayrollMinimal(
            boolean processed,
            String uuid,
            String payrollUuid,
            String companyUuid) {
        this(Optional.empty(), Optional.empty(), processed, Optional.empty(), Optional.empty(), uuid, payrollUuid, companyUuid, Optional.empty(), JsonNullable.undefined(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty());
    }

    /**
     * A timestamp that is the deadline for the payroll to be run in order for employees to be paid on time.  If payroll has not been run by the deadline, a prepare request will update both the check date and deadline to reflect the soonest employees can be paid and the deadline by which the payroll must be run in order for said check date to be met.
     */
    @JsonIgnore
    public Optional<OffsetDateTime> payrollDeadline() {
        return payrollDeadline;
    }

    /**
     * The date on which employees will be paid for the payroll.
     */
    @JsonIgnore
    public Optional<String> checkDate() {
        return checkDate;
    }

    /**
     * Whether or not the payroll has been successfully processed. Note that processed payrolls cannot be updated. Additionally, a payroll is not guaranteed to be processed just because the payroll deadline has passed. Late payrolls are not uncommon. Conversely, users may choose to run payroll before the payroll deadline.
     */
    @JsonIgnore
    public boolean processed() {
        return processed;
    }

    /**
     * The date at which the payroll was processed. Null if the payroll isn't processed yet.
     */
    @JsonIgnore
    public Optional<String> processedDate() {
        return processedDate;
    }

    /**
     * A timestamp of the last valid payroll calculation. Null if there isn't a valid calculation.
     */
    @JsonIgnore
    public Optional<String> calculatedAt() {
        return calculatedAt;
    }

    /**
     * The UUID of the payroll.
     */
    @JsonIgnore
    public String uuid() {
        return uuid;
    }

    /**
     * The UUID of the payroll.
     */
    @JsonIgnore
    public String payrollUuid() {
        return payrollUuid;
    }

    /**
     * The UUID of the company for the payroll.
     */
    @JsonIgnore
    public String companyUuid() {
        return companyUuid;
    }

    /**
     * Indicates whether the payroll is an off-cycle payroll
     */
    @JsonIgnore
    public Optional<Boolean> offCycle() {
        return offCycle;
    }

    /**
     * The off-cycle reason. Only included for off-cycle payrolls.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<OffCycleReasonType> offCycleReason() {
        return (JsonNullable<OffCycleReasonType>) offCycleReason;
    }

    /**
     * Indicates whether the payroll is an auto pilot payroll
     */
    @JsonIgnore
    public Optional<Boolean> autoPilot() {
        return autoPilot;
    }

    /**
     * Indicates whether the payroll is an external payroll
     */
    @JsonIgnore
    public Optional<Boolean> external() {
        return external;
    }

    /**
     * Indicates whether the payroll is the final payroll for a terminated employee. Only included for off-cycle payrolls.
     */
    @JsonIgnore
    public Optional<Boolean> finalTerminationPayroll() {
        return finalTerminationPayroll;
    }

    /**
     * The payment schedule tax rate the payroll is based on. Only included for off-cycle payrolls.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<PayrollWithholdingPayPeriodType> withholdingPayPeriod() {
        return (Optional<PayrollWithholdingPayPeriodType>) withholdingPayPeriod;
    }

    /**
     * Block regular deductions and contributions for this payroll.  Only included for off-cycle payrolls.
     */
    @JsonIgnore
    public Optional<Boolean> skipRegularDeductions() {
        return skipRegularDeductions;
    }

    /**
     * Enable taxes to be withheld at the IRS's required rate of 22% for federal income taxes. State income taxes will be taxed at the state's supplemental tax rate. Otherwise, we'll sum the entirety of the employee's wages and withhold taxes on the entire amount at the rate for regular wages. Only included for off-cycle payrolls.
     */
    @JsonIgnore
    public Optional<Boolean> fixedWithholdingRate() {
        return fixedWithholdingRate;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<PayrollPayPeriodType> payPeriod() {
        return (Optional<PayrollPayPeriodType>) payPeriod;
    }

    /**
     * Information about the payroll's status and expected dates
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<PayrollPayrollStatusMetaType> payrollStatusMeta() {
        return (Optional<PayrollPayrollStatusMetaType>) payrollStatusMeta;
    }

    /**
     * The subtotals for the payroll.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<PayrollTotalsType> totals() {
        return (Optional<PayrollTotalsType>) totals;
    }

    /**
     * Only applicable when a payroll is moved to four day processing instead of fast ach.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<PayrollPaymentSpeedChangedType> paymentSpeedChanged() {
        return (Optional<PayrollPaymentSpeedChangedType>) paymentSpeedChanged;
    }

    /**
     * Datetime for when the resource was created.
     */
    @JsonIgnore
    public Optional<OffsetDateTime> createdAt() {
        return createdAt;
    }

    /**
     * Only included for processed or calculated payrolls
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<PayrollSubmissionBlockersType>> submissionBlockers() {
        return (Optional<List<PayrollSubmissionBlockersType>>) submissionBlockers;
    }

    /**
     * Only included for processed payrolls
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<PayrollCreditBlockersType>> creditBlockers() {
        return (Optional<List<PayrollCreditBlockersType>>) creditBlockers;
    }

    public final static Builder builder() {
        return new Builder();
    }

    /**
     * A timestamp that is the deadline for the payroll to be run in order for employees to be paid on time.  If payroll has not been run by the deadline, a prepare request will update both the check date and deadline to reflect the soonest employees can be paid and the deadline by which the payroll must be run in order for said check date to be met.
     */
    public PayrollMinimal withPayrollDeadline(OffsetDateTime payrollDeadline) {
        Utils.checkNotNull(payrollDeadline, "payrollDeadline");
        this.payrollDeadline = Optional.ofNullable(payrollDeadline);
        return this;
    }

    /**
     * A timestamp that is the deadline for the payroll to be run in order for employees to be paid on time.  If payroll has not been run by the deadline, a prepare request will update both the check date and deadline to reflect the soonest employees can be paid and the deadline by which the payroll must be run in order for said check date to be met.
     */
    public PayrollMinimal withPayrollDeadline(Optional<OffsetDateTime> payrollDeadline) {
        Utils.checkNotNull(payrollDeadline, "payrollDeadline");
        this.payrollDeadline = payrollDeadline;
        return this;
    }

    /**
     * The date on which employees will be paid for the payroll.
     */
    public PayrollMinimal withCheckDate(String checkDate) {
        Utils.checkNotNull(checkDate, "checkDate");
        this.checkDate = Optional.ofNullable(checkDate);
        return this;
    }

    /**
     * The date on which employees will be paid for the payroll.
     */
    public PayrollMinimal withCheckDate(Optional<String> checkDate) {
        Utils.checkNotNull(checkDate, "checkDate");
        this.checkDate = checkDate;
        return this;
    }

    /**
     * Whether or not the payroll has been successfully processed. Note that processed payrolls cannot be updated. Additionally, a payroll is not guaranteed to be processed just because the payroll deadline has passed. Late payrolls are not uncommon. Conversely, users may choose to run payroll before the payroll deadline.
     */
    public PayrollMinimal withProcessed(boolean processed) {
        Utils.checkNotNull(processed, "processed");
        this.processed = processed;
        return this;
    }

    /**
     * The date at which the payroll was processed. Null if the payroll isn't processed yet.
     */
    public PayrollMinimal withProcessedDate(String processedDate) {
        Utils.checkNotNull(processedDate, "processedDate");
        this.processedDate = Optional.ofNullable(processedDate);
        return this;
    }

    /**
     * The date at which the payroll was processed. Null if the payroll isn't processed yet.
     */
    public PayrollMinimal withProcessedDate(Optional<String> processedDate) {
        Utils.checkNotNull(processedDate, "processedDate");
        this.processedDate = processedDate;
        return this;
    }

    /**
     * A timestamp of the last valid payroll calculation. Null if there isn't a valid calculation.
     */
    public PayrollMinimal withCalculatedAt(String calculatedAt) {
        Utils.checkNotNull(calculatedAt, "calculatedAt");
        this.calculatedAt = Optional.ofNullable(calculatedAt);
        return this;
    }

    /**
     * A timestamp of the last valid payroll calculation. Null if there isn't a valid calculation.
     */
    public PayrollMinimal withCalculatedAt(Optional<String> calculatedAt) {
        Utils.checkNotNull(calculatedAt, "calculatedAt");
        this.calculatedAt = calculatedAt;
        return this;
    }

    /**
     * The UUID of the payroll.
     */
    public PayrollMinimal withUuid(String uuid) {
        Utils.checkNotNull(uuid, "uuid");
        this.uuid = uuid;
        return this;
    }

    /**
     * The UUID of the payroll.
     */
    public PayrollMinimal withPayrollUuid(String payrollUuid) {
        Utils.checkNotNull(payrollUuid, "payrollUuid");
        this.payrollUuid = payrollUuid;
        return this;
    }

    /**
     * The UUID of the company for the payroll.
     */
    public PayrollMinimal withCompanyUuid(String companyUuid) {
        Utils.checkNotNull(companyUuid, "companyUuid");
        this.companyUuid = companyUuid;
        return this;
    }

    /**
     * Indicates whether the payroll is an off-cycle payroll
     */
    public PayrollMinimal withOffCycle(boolean offCycle) {
        Utils.checkNotNull(offCycle, "offCycle");
        this.offCycle = Optional.ofNullable(offCycle);
        return this;
    }

    /**
     * Indicates whether the payroll is an off-cycle payroll
     */
    public PayrollMinimal withOffCycle(Optional<Boolean> offCycle) {
        Utils.checkNotNull(offCycle, "offCycle");
        this.offCycle = offCycle;
        return this;
    }

    /**
     * The off-cycle reason. Only included for off-cycle payrolls.
     */
    public PayrollMinimal withOffCycleReason(OffCycleReasonType offCycleReason) {
        Utils.checkNotNull(offCycleReason, "offCycleReason");
        this.offCycleReason = JsonNullable.of(offCycleReason);
        return this;
    }

    /**
     * The off-cycle reason. Only included for off-cycle payrolls.
     */
    public PayrollMinimal withOffCycleReason(JsonNullable<? extends OffCycleReasonType> offCycleReason) {
        Utils.checkNotNull(offCycleReason, "offCycleReason");
        this.offCycleReason = offCycleReason;
        return this;
    }

    /**
     * Indicates whether the payroll is an auto pilot payroll
     */
    public PayrollMinimal withAutoPilot(boolean autoPilot) {
        Utils.checkNotNull(autoPilot, "autoPilot");
        this.autoPilot = Optional.ofNullable(autoPilot);
        return this;
    }

    /**
     * Indicates whether the payroll is an auto pilot payroll
     */
    public PayrollMinimal withAutoPilot(Optional<Boolean> autoPilot) {
        Utils.checkNotNull(autoPilot, "autoPilot");
        this.autoPilot = autoPilot;
        return this;
    }

    /**
     * Indicates whether the payroll is an external payroll
     */
    public PayrollMinimal withExternal(boolean external) {
        Utils.checkNotNull(external, "external");
        this.external = Optional.ofNullable(external);
        return this;
    }

    /**
     * Indicates whether the payroll is an external payroll
     */
    public PayrollMinimal withExternal(Optional<Boolean> external) {
        Utils.checkNotNull(external, "external");
        this.external = external;
        return this;
    }

    /**
     * Indicates whether the payroll is the final payroll for a terminated employee. Only included for off-cycle payrolls.
     */
    public PayrollMinimal withFinalTerminationPayroll(boolean finalTerminationPayroll) {
        Utils.checkNotNull(finalTerminationPayroll, "finalTerminationPayroll");
        this.finalTerminationPayroll = Optional.ofNullable(finalTerminationPayroll);
        return this;
    }

    /**
     * Indicates whether the payroll is the final payroll for a terminated employee. Only included for off-cycle payrolls.
     */
    public PayrollMinimal withFinalTerminationPayroll(Optional<Boolean> finalTerminationPayroll) {
        Utils.checkNotNull(finalTerminationPayroll, "finalTerminationPayroll");
        this.finalTerminationPayroll = finalTerminationPayroll;
        return this;
    }

    /**
     * The payment schedule tax rate the payroll is based on. Only included for off-cycle payrolls.
     */
    public PayrollMinimal withWithholdingPayPeriod(PayrollWithholdingPayPeriodType withholdingPayPeriod) {
        Utils.checkNotNull(withholdingPayPeriod, "withholdingPayPeriod");
        this.withholdingPayPeriod = Optional.ofNullable(withholdingPayPeriod);
        return this;
    }

    /**
     * The payment schedule tax rate the payroll is based on. Only included for off-cycle payrolls.
     */
    public PayrollMinimal withWithholdingPayPeriod(Optional<? extends PayrollWithholdingPayPeriodType> withholdingPayPeriod) {
        Utils.checkNotNull(withholdingPayPeriod, "withholdingPayPeriod");
        this.withholdingPayPeriod = withholdingPayPeriod;
        return this;
    }

    /**
     * Block regular deductions and contributions for this payroll.  Only included for off-cycle payrolls.
     */
    public PayrollMinimal withSkipRegularDeductions(boolean skipRegularDeductions) {
        Utils.checkNotNull(skipRegularDeductions, "skipRegularDeductions");
        this.skipRegularDeductions = Optional.ofNullable(skipRegularDeductions);
        return this;
    }

    /**
     * Block regular deductions and contributions for this payroll.  Only included for off-cycle payrolls.
     */
    public PayrollMinimal withSkipRegularDeductions(Optional<Boolean> skipRegularDeductions) {
        Utils.checkNotNull(skipRegularDeductions, "skipRegularDeductions");
        this.skipRegularDeductions = skipRegularDeductions;
        return this;
    }

    /**
     * Enable taxes to be withheld at the IRS's required rate of 22% for federal income taxes. State income taxes will be taxed at the state's supplemental tax rate. Otherwise, we'll sum the entirety of the employee's wages and withhold taxes on the entire amount at the rate for regular wages. Only included for off-cycle payrolls.
     */
    public PayrollMinimal withFixedWithholdingRate(boolean fixedWithholdingRate) {
        Utils.checkNotNull(fixedWithholdingRate, "fixedWithholdingRate");
        this.fixedWithholdingRate = Optional.ofNullable(fixedWithholdingRate);
        return this;
    }

    /**
     * Enable taxes to be withheld at the IRS's required rate of 22% for federal income taxes. State income taxes will be taxed at the state's supplemental tax rate. Otherwise, we'll sum the entirety of the employee's wages and withhold taxes on the entire amount at the rate for regular wages. Only included for off-cycle payrolls.
     */
    public PayrollMinimal withFixedWithholdingRate(Optional<Boolean> fixedWithholdingRate) {
        Utils.checkNotNull(fixedWithholdingRate, "fixedWithholdingRate");
        this.fixedWithholdingRate = fixedWithholdingRate;
        return this;
    }

    public PayrollMinimal withPayPeriod(PayrollPayPeriodType payPeriod) {
        Utils.checkNotNull(payPeriod, "payPeriod");
        this.payPeriod = Optional.ofNullable(payPeriod);
        return this;
    }

    public PayrollMinimal withPayPeriod(Optional<? extends PayrollPayPeriodType> payPeriod) {
        Utils.checkNotNull(payPeriod, "payPeriod");
        this.payPeriod = payPeriod;
        return this;
    }

    /**
     * Information about the payroll's status and expected dates
     */
    public PayrollMinimal withPayrollStatusMeta(PayrollPayrollStatusMetaType payrollStatusMeta) {
        Utils.checkNotNull(payrollStatusMeta, "payrollStatusMeta");
        this.payrollStatusMeta = Optional.ofNullable(payrollStatusMeta);
        return this;
    }

    /**
     * Information about the payroll's status and expected dates
     */
    public PayrollMinimal withPayrollStatusMeta(Optional<? extends PayrollPayrollStatusMetaType> payrollStatusMeta) {
        Utils.checkNotNull(payrollStatusMeta, "payrollStatusMeta");
        this.payrollStatusMeta = payrollStatusMeta;
        return this;
    }

    /**
     * The subtotals for the payroll.
     */
    public PayrollMinimal withTotals(PayrollTotalsType totals) {
        Utils.checkNotNull(totals, "totals");
        this.totals = Optional.ofNullable(totals);
        return this;
    }

    /**
     * The subtotals for the payroll.
     */
    public PayrollMinimal withTotals(Optional<? extends PayrollTotalsType> totals) {
        Utils.checkNotNull(totals, "totals");
        this.totals = totals;
        return this;
    }

    /**
     * Only applicable when a payroll is moved to four day processing instead of fast ach.
     */
    public PayrollMinimal withPaymentSpeedChanged(PayrollPaymentSpeedChangedType paymentSpeedChanged) {
        Utils.checkNotNull(paymentSpeedChanged, "paymentSpeedChanged");
        this.paymentSpeedChanged = Optional.ofNullable(paymentSpeedChanged);
        return this;
    }

    /**
     * Only applicable when a payroll is moved to four day processing instead of fast ach.
     */
    public PayrollMinimal withPaymentSpeedChanged(Optional<? extends PayrollPaymentSpeedChangedType> paymentSpeedChanged) {
        Utils.checkNotNull(paymentSpeedChanged, "paymentSpeedChanged");
        this.paymentSpeedChanged = paymentSpeedChanged;
        return this;
    }

    /**
     * Datetime for when the resource was created.
     */
    public PayrollMinimal withCreatedAt(OffsetDateTime createdAt) {
        Utils.checkNotNull(createdAt, "createdAt");
        this.createdAt = Optional.ofNullable(createdAt);
        return this;
    }

    /**
     * Datetime for when the resource was created.
     */
    public PayrollMinimal withCreatedAt(Optional<OffsetDateTime> createdAt) {
        Utils.checkNotNull(createdAt, "createdAt");
        this.createdAt = createdAt;
        return this;
    }

    /**
     * Only included for processed or calculated payrolls
     */
    public PayrollMinimal withSubmissionBlockers(List<PayrollSubmissionBlockersType> submissionBlockers) {
        Utils.checkNotNull(submissionBlockers, "submissionBlockers");
        this.submissionBlockers = Optional.ofNullable(submissionBlockers);
        return this;
    }

    /**
     * Only included for processed or calculated payrolls
     */
    public PayrollMinimal withSubmissionBlockers(Optional<? extends List<PayrollSubmissionBlockersType>> submissionBlockers) {
        Utils.checkNotNull(submissionBlockers, "submissionBlockers");
        this.submissionBlockers = submissionBlockers;
        return this;
    }

    /**
     * Only included for processed payrolls
     */
    public PayrollMinimal withCreditBlockers(List<PayrollCreditBlockersType> creditBlockers) {
        Utils.checkNotNull(creditBlockers, "creditBlockers");
        this.creditBlockers = Optional.ofNullable(creditBlockers);
        return this;
    }

    /**
     * Only included for processed payrolls
     */
    public PayrollMinimal withCreditBlockers(Optional<? extends List<PayrollCreditBlockersType>> creditBlockers) {
        Utils.checkNotNull(creditBlockers, "creditBlockers");
        this.creditBlockers = creditBlockers;
        return this;
    }
    
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        PayrollMinimal other = (PayrollMinimal) o;
        return 
            Objects.deepEquals(this.payrollDeadline, other.payrollDeadline) &&
            Objects.deepEquals(this.checkDate, other.checkDate) &&
            Objects.deepEquals(this.processed, other.processed) &&
            Objects.deepEquals(this.processedDate, other.processedDate) &&
            Objects.deepEquals(this.calculatedAt, other.calculatedAt) &&
            Objects.deepEquals(this.uuid, other.uuid) &&
            Objects.deepEquals(this.payrollUuid, other.payrollUuid) &&
            Objects.deepEquals(this.companyUuid, other.companyUuid) &&
            Objects.deepEquals(this.offCycle, other.offCycle) &&
            Objects.deepEquals(this.offCycleReason, other.offCycleReason) &&
            Objects.deepEquals(this.autoPilot, other.autoPilot) &&
            Objects.deepEquals(this.external, other.external) &&
            Objects.deepEquals(this.finalTerminationPayroll, other.finalTerminationPayroll) &&
            Objects.deepEquals(this.withholdingPayPeriod, other.withholdingPayPeriod) &&
            Objects.deepEquals(this.skipRegularDeductions, other.skipRegularDeductions) &&
            Objects.deepEquals(this.fixedWithholdingRate, other.fixedWithholdingRate) &&
            Objects.deepEquals(this.payPeriod, other.payPeriod) &&
            Objects.deepEquals(this.payrollStatusMeta, other.payrollStatusMeta) &&
            Objects.deepEquals(this.totals, other.totals) &&
            Objects.deepEquals(this.paymentSpeedChanged, other.paymentSpeedChanged) &&
            Objects.deepEquals(this.createdAt, other.createdAt) &&
            Objects.deepEquals(this.submissionBlockers, other.submissionBlockers) &&
            Objects.deepEquals(this.creditBlockers, other.creditBlockers);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(
            payrollDeadline,
            checkDate,
            processed,
            processedDate,
            calculatedAt,
            uuid,
            payrollUuid,
            companyUuid,
            offCycle,
            offCycleReason,
            autoPilot,
            external,
            finalTerminationPayroll,
            withholdingPayPeriod,
            skipRegularDeductions,
            fixedWithholdingRate,
            payPeriod,
            payrollStatusMeta,
            totals,
            paymentSpeedChanged,
            createdAt,
            submissionBlockers,
            creditBlockers);
    }
    
    @Override
    public String toString() {
        return Utils.toString(PayrollMinimal.class,
                "payrollDeadline", payrollDeadline,
                "checkDate", checkDate,
                "processed", processed,
                "processedDate", processedDate,
                "calculatedAt", calculatedAt,
                "uuid", uuid,
                "payrollUuid", payrollUuid,
                "companyUuid", companyUuid,
                "offCycle", offCycle,
                "offCycleReason", offCycleReason,
                "autoPilot", autoPilot,
                "external", external,
                "finalTerminationPayroll", finalTerminationPayroll,
                "withholdingPayPeriod", withholdingPayPeriod,
                "skipRegularDeductions", skipRegularDeductions,
                "fixedWithholdingRate", fixedWithholdingRate,
                "payPeriod", payPeriod,
                "payrollStatusMeta", payrollStatusMeta,
                "totals", totals,
                "paymentSpeedChanged", paymentSpeedChanged,
                "createdAt", createdAt,
                "submissionBlockers", submissionBlockers,
                "creditBlockers", creditBlockers);
    }
    
    public final static class Builder {
 
        private Optional<OffsetDateTime> payrollDeadline = Optional.empty();
 
        private Optional<String> checkDate = Optional.empty();
 
        private Boolean processed;
 
        private Optional<String> processedDate = Optional.empty();
 
        private Optional<String> calculatedAt = Optional.empty();
 
        private String uuid;
 
        private String payrollUuid;
 
        private String companyUuid;
 
        private Optional<Boolean> offCycle = Optional.empty();
 
        private JsonNullable<? extends OffCycleReasonType> offCycleReason = JsonNullable.undefined();
 
        private Optional<Boolean> autoPilot = Optional.empty();
 
        private Optional<Boolean> external = Optional.empty();
 
        private Optional<Boolean> finalTerminationPayroll = Optional.empty();
 
        private Optional<? extends PayrollWithholdingPayPeriodType> withholdingPayPeriod = Optional.empty();
 
        private Optional<Boolean> skipRegularDeductions = Optional.empty();
 
        private Optional<Boolean> fixedWithholdingRate = Optional.empty();
 
        private Optional<? extends PayrollPayPeriodType> payPeriod = Optional.empty();
 
        private Optional<? extends PayrollPayrollStatusMetaType> payrollStatusMeta = Optional.empty();
 
        private Optional<? extends PayrollTotalsType> totals = Optional.empty();
 
        private Optional<? extends PayrollPaymentSpeedChangedType> paymentSpeedChanged = Optional.empty();
 
        private Optional<OffsetDateTime> createdAt = Optional.empty();
 
        private Optional<? extends List<PayrollSubmissionBlockersType>> submissionBlockers = Optional.empty();
 
        private Optional<? extends List<PayrollCreditBlockersType>> creditBlockers = Optional.empty();  
        
        private Builder() {
          // force use of static builder() method
        }

        /**
         * A timestamp that is the deadline for the payroll to be run in order for employees to be paid on time.  If payroll has not been run by the deadline, a prepare request will update both the check date and deadline to reflect the soonest employees can be paid and the deadline by which the payroll must be run in order for said check date to be met.
         */
        public Builder payrollDeadline(OffsetDateTime payrollDeadline) {
            Utils.checkNotNull(payrollDeadline, "payrollDeadline");
            this.payrollDeadline = Optional.ofNullable(payrollDeadline);
            return this;
        }

        /**
         * A timestamp that is the deadline for the payroll to be run in order for employees to be paid on time.  If payroll has not been run by the deadline, a prepare request will update both the check date and deadline to reflect the soonest employees can be paid and the deadline by which the payroll must be run in order for said check date to be met.
         */
        public Builder payrollDeadline(Optional<OffsetDateTime> payrollDeadline) {
            Utils.checkNotNull(payrollDeadline, "payrollDeadline");
            this.payrollDeadline = payrollDeadline;
            return this;
        }

        /**
         * The date on which employees will be paid for the payroll.
         */
        public Builder checkDate(String checkDate) {
            Utils.checkNotNull(checkDate, "checkDate");
            this.checkDate = Optional.ofNullable(checkDate);
            return this;
        }

        /**
         * The date on which employees will be paid for the payroll.
         */
        public Builder checkDate(Optional<String> checkDate) {
            Utils.checkNotNull(checkDate, "checkDate");
            this.checkDate = checkDate;
            return this;
        }

        /**
         * Whether or not the payroll has been successfully processed. Note that processed payrolls cannot be updated. Additionally, a payroll is not guaranteed to be processed just because the payroll deadline has passed. Late payrolls are not uncommon. Conversely, users may choose to run payroll before the payroll deadline.
         */
        public Builder processed(boolean processed) {
            Utils.checkNotNull(processed, "processed");
            this.processed = processed;
            return this;
        }

        /**
         * The date at which the payroll was processed. Null if the payroll isn't processed yet.
         */
        public Builder processedDate(String processedDate) {
            Utils.checkNotNull(processedDate, "processedDate");
            this.processedDate = Optional.ofNullable(processedDate);
            return this;
        }

        /**
         * The date at which the payroll was processed. Null if the payroll isn't processed yet.
         */
        public Builder processedDate(Optional<String> processedDate) {
            Utils.checkNotNull(processedDate, "processedDate");
            this.processedDate = processedDate;
            return this;
        }

        /**
         * A timestamp of the last valid payroll calculation. Null if there isn't a valid calculation.
         */
        public Builder calculatedAt(String calculatedAt) {
            Utils.checkNotNull(calculatedAt, "calculatedAt");
            this.calculatedAt = Optional.ofNullable(calculatedAt);
            return this;
        }

        /**
         * A timestamp of the last valid payroll calculation. Null if there isn't a valid calculation.
         */
        public Builder calculatedAt(Optional<String> calculatedAt) {
            Utils.checkNotNull(calculatedAt, "calculatedAt");
            this.calculatedAt = calculatedAt;
            return this;
        }

        /**
         * The UUID of the payroll.
         */
        public Builder uuid(String uuid) {
            Utils.checkNotNull(uuid, "uuid");
            this.uuid = uuid;
            return this;
        }

        /**
         * The UUID of the payroll.
         */
        public Builder payrollUuid(String payrollUuid) {
            Utils.checkNotNull(payrollUuid, "payrollUuid");
            this.payrollUuid = payrollUuid;
            return this;
        }

        /**
         * The UUID of the company for the payroll.
         */
        public Builder companyUuid(String companyUuid) {
            Utils.checkNotNull(companyUuid, "companyUuid");
            this.companyUuid = companyUuid;
            return this;
        }

        /**
         * Indicates whether the payroll is an off-cycle payroll
         */
        public Builder offCycle(boolean offCycle) {
            Utils.checkNotNull(offCycle, "offCycle");
            this.offCycle = Optional.ofNullable(offCycle);
            return this;
        }

        /**
         * Indicates whether the payroll is an off-cycle payroll
         */
        public Builder offCycle(Optional<Boolean> offCycle) {
            Utils.checkNotNull(offCycle, "offCycle");
            this.offCycle = offCycle;
            return this;
        }

        /**
         * The off-cycle reason. Only included for off-cycle payrolls.
         */
        public Builder offCycleReason(OffCycleReasonType offCycleReason) {
            Utils.checkNotNull(offCycleReason, "offCycleReason");
            this.offCycleReason = JsonNullable.of(offCycleReason);
            return this;
        }

        /**
         * The off-cycle reason. Only included for off-cycle payrolls.
         */
        public Builder offCycleReason(JsonNullable<? extends OffCycleReasonType> offCycleReason) {
            Utils.checkNotNull(offCycleReason, "offCycleReason");
            this.offCycleReason = offCycleReason;
            return this;
        }

        /**
         * Indicates whether the payroll is an auto pilot payroll
         */
        public Builder autoPilot(boolean autoPilot) {
            Utils.checkNotNull(autoPilot, "autoPilot");
            this.autoPilot = Optional.ofNullable(autoPilot);
            return this;
        }

        /**
         * Indicates whether the payroll is an auto pilot payroll
         */
        public Builder autoPilot(Optional<Boolean> autoPilot) {
            Utils.checkNotNull(autoPilot, "autoPilot");
            this.autoPilot = autoPilot;
            return this;
        }

        /**
         * Indicates whether the payroll is an external payroll
         */
        public Builder external(boolean external) {
            Utils.checkNotNull(external, "external");
            this.external = Optional.ofNullable(external);
            return this;
        }

        /**
         * Indicates whether the payroll is an external payroll
         */
        public Builder external(Optional<Boolean> external) {
            Utils.checkNotNull(external, "external");
            this.external = external;
            return this;
        }

        /**
         * Indicates whether the payroll is the final payroll for a terminated employee. Only included for off-cycle payrolls.
         */
        public Builder finalTerminationPayroll(boolean finalTerminationPayroll) {
            Utils.checkNotNull(finalTerminationPayroll, "finalTerminationPayroll");
            this.finalTerminationPayroll = Optional.ofNullable(finalTerminationPayroll);
            return this;
        }

        /**
         * Indicates whether the payroll is the final payroll for a terminated employee. Only included for off-cycle payrolls.
         */
        public Builder finalTerminationPayroll(Optional<Boolean> finalTerminationPayroll) {
            Utils.checkNotNull(finalTerminationPayroll, "finalTerminationPayroll");
            this.finalTerminationPayroll = finalTerminationPayroll;
            return this;
        }

        /**
         * The payment schedule tax rate the payroll is based on. Only included for off-cycle payrolls.
         */
        public Builder withholdingPayPeriod(PayrollWithholdingPayPeriodType withholdingPayPeriod) {
            Utils.checkNotNull(withholdingPayPeriod, "withholdingPayPeriod");
            this.withholdingPayPeriod = Optional.ofNullable(withholdingPayPeriod);
            return this;
        }

        /**
         * The payment schedule tax rate the payroll is based on. Only included for off-cycle payrolls.
         */
        public Builder withholdingPayPeriod(Optional<? extends PayrollWithholdingPayPeriodType> withholdingPayPeriod) {
            Utils.checkNotNull(withholdingPayPeriod, "withholdingPayPeriod");
            this.withholdingPayPeriod = withholdingPayPeriod;
            return this;
        }

        /**
         * Block regular deductions and contributions for this payroll.  Only included for off-cycle payrolls.
         */
        public Builder skipRegularDeductions(boolean skipRegularDeductions) {
            Utils.checkNotNull(skipRegularDeductions, "skipRegularDeductions");
            this.skipRegularDeductions = Optional.ofNullable(skipRegularDeductions);
            return this;
        }

        /**
         * Block regular deductions and contributions for this payroll.  Only included for off-cycle payrolls.
         */
        public Builder skipRegularDeductions(Optional<Boolean> skipRegularDeductions) {
            Utils.checkNotNull(skipRegularDeductions, "skipRegularDeductions");
            this.skipRegularDeductions = skipRegularDeductions;
            return this;
        }

        /**
         * Enable taxes to be withheld at the IRS's required rate of 22% for federal income taxes. State income taxes will be taxed at the state's supplemental tax rate. Otherwise, we'll sum the entirety of the employee's wages and withhold taxes on the entire amount at the rate for regular wages. Only included for off-cycle payrolls.
         */
        public Builder fixedWithholdingRate(boolean fixedWithholdingRate) {
            Utils.checkNotNull(fixedWithholdingRate, "fixedWithholdingRate");
            this.fixedWithholdingRate = Optional.ofNullable(fixedWithholdingRate);
            return this;
        }

        /**
         * Enable taxes to be withheld at the IRS's required rate of 22% for federal income taxes. State income taxes will be taxed at the state's supplemental tax rate. Otherwise, we'll sum the entirety of the employee's wages and withhold taxes on the entire amount at the rate for regular wages. Only included for off-cycle payrolls.
         */
        public Builder fixedWithholdingRate(Optional<Boolean> fixedWithholdingRate) {
            Utils.checkNotNull(fixedWithholdingRate, "fixedWithholdingRate");
            this.fixedWithholdingRate = fixedWithholdingRate;
            return this;
        }

        public Builder payPeriod(PayrollPayPeriodType payPeriod) {
            Utils.checkNotNull(payPeriod, "payPeriod");
            this.payPeriod = Optional.ofNullable(payPeriod);
            return this;
        }

        public Builder payPeriod(Optional<? extends PayrollPayPeriodType> payPeriod) {
            Utils.checkNotNull(payPeriod, "payPeriod");
            this.payPeriod = payPeriod;
            return this;
        }

        /**
         * Information about the payroll's status and expected dates
         */
        public Builder payrollStatusMeta(PayrollPayrollStatusMetaType payrollStatusMeta) {
            Utils.checkNotNull(payrollStatusMeta, "payrollStatusMeta");
            this.payrollStatusMeta = Optional.ofNullable(payrollStatusMeta);
            return this;
        }

        /**
         * Information about the payroll's status and expected dates
         */
        public Builder payrollStatusMeta(Optional<? extends PayrollPayrollStatusMetaType> payrollStatusMeta) {
            Utils.checkNotNull(payrollStatusMeta, "payrollStatusMeta");
            this.payrollStatusMeta = payrollStatusMeta;
            return this;
        }

        /**
         * The subtotals for the payroll.
         */
        public Builder totals(PayrollTotalsType totals) {
            Utils.checkNotNull(totals, "totals");
            this.totals = Optional.ofNullable(totals);
            return this;
        }

        /**
         * The subtotals for the payroll.
         */
        public Builder totals(Optional<? extends PayrollTotalsType> totals) {
            Utils.checkNotNull(totals, "totals");
            this.totals = totals;
            return this;
        }

        /**
         * Only applicable when a payroll is moved to four day processing instead of fast ach.
         */
        public Builder paymentSpeedChanged(PayrollPaymentSpeedChangedType paymentSpeedChanged) {
            Utils.checkNotNull(paymentSpeedChanged, "paymentSpeedChanged");
            this.paymentSpeedChanged = Optional.ofNullable(paymentSpeedChanged);
            return this;
        }

        /**
         * Only applicable when a payroll is moved to four day processing instead of fast ach.
         */
        public Builder paymentSpeedChanged(Optional<? extends PayrollPaymentSpeedChangedType> paymentSpeedChanged) {
            Utils.checkNotNull(paymentSpeedChanged, "paymentSpeedChanged");
            this.paymentSpeedChanged = paymentSpeedChanged;
            return this;
        }

        /**
         * Datetime for when the resource was created.
         */
        public Builder createdAt(OffsetDateTime createdAt) {
            Utils.checkNotNull(createdAt, "createdAt");
            this.createdAt = Optional.ofNullable(createdAt);
            return this;
        }

        /**
         * Datetime for when the resource was created.
         */
        public Builder createdAt(Optional<OffsetDateTime> createdAt) {
            Utils.checkNotNull(createdAt, "createdAt");
            this.createdAt = createdAt;
            return this;
        }

        /**
         * Only included for processed or calculated payrolls
         */
        public Builder submissionBlockers(List<PayrollSubmissionBlockersType> submissionBlockers) {
            Utils.checkNotNull(submissionBlockers, "submissionBlockers");
            this.submissionBlockers = Optional.ofNullable(submissionBlockers);
            return this;
        }

        /**
         * Only included for processed or calculated payrolls
         */
        public Builder submissionBlockers(Optional<? extends List<PayrollSubmissionBlockersType>> submissionBlockers) {
            Utils.checkNotNull(submissionBlockers, "submissionBlockers");
            this.submissionBlockers = submissionBlockers;
            return this;
        }

        /**
         * Only included for processed payrolls
         */
        public Builder creditBlockers(List<PayrollCreditBlockersType> creditBlockers) {
            Utils.checkNotNull(creditBlockers, "creditBlockers");
            this.creditBlockers = Optional.ofNullable(creditBlockers);
            return this;
        }

        /**
         * Only included for processed payrolls
         */
        public Builder creditBlockers(Optional<? extends List<PayrollCreditBlockersType>> creditBlockers) {
            Utils.checkNotNull(creditBlockers, "creditBlockers");
            this.creditBlockers = creditBlockers;
            return this;
        }
        
        public PayrollMinimal build() {
            return new PayrollMinimal(
                payrollDeadline,
                checkDate,
                processed,
                processedDate,
                calculatedAt,
                uuid,
                payrollUuid,
                companyUuid,
                offCycle,
                offCycleReason,
                autoPilot,
                external,
                finalTerminationPayroll,
                withholdingPayPeriod,
                skipRegularDeductions,
                fixedWithholdingRate,
                payPeriod,
                payrollStatusMeta,
                totals,
                paymentSpeedChanged,
                createdAt,
                submissionBlockers,
                creditBlockers);
        }
    }
}

