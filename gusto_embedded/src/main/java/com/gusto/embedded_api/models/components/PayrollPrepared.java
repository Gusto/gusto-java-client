/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */


package com.gusto.embedded_api.models.components;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.gusto.embedded_api.utils.Utils;
import java.lang.Boolean;
import java.lang.Override;
import java.lang.String;
import java.lang.SuppressWarnings;
import java.time.OffsetDateTime;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import org.openapitools.jackson.nullable.JsonNullable;
/**
 * PayrollPrepared - An off-cycle payroll
 */

public class PayrollPrepared {

    /**
     * A timestamp that is the deadline for the payroll to be run in order for employees to be paid on time.  If payroll has not been run by the deadline, a prepare request will update both the check date and deadline to reflect the soonest employees can be paid and the deadline by which the payroll must be run in order for said check date to be met.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("payroll_deadline")
    private Optional<OffsetDateTime> payrollDeadline;

    /**
     * The date on which employees will be paid for the payroll.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("check_date")
    private Optional<String> checkDate;

    /**
     * Whether or not the payroll has been successfully processed. Note that processed payrolls cannot be updated. Additionally, a payroll is not guaranteed to be processed just because the payroll deadline has passed. Late payrolls are not uncommon. Conversely, users may choose to run payroll before the payroll deadline.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("processed")
    private Optional<Boolean> processed;

    /**
     * The date at which the payroll was processed. Null if the payroll isn't processed yet.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("processed_date")
    private Optional<String> processedDate;

    /**
     * A timestamp of the last valid payroll calculation. Null if there isn't a valid calculation.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("calculated_at")
    private Optional<String> calculatedAt;

    /**
     * The UUID of the payroll.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("uuid")
    private Optional<String> uuid;

    /**
     * The UUID of the payroll.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("payroll_uuid")
    private Optional<String> payrollUuid;

    /**
     * The UUID of the company for the payroll.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("company_uuid")
    private Optional<String> companyUuid;

    /**
     * Indicates whether the payroll is an off-cycle payroll
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("off_cycle")
    private Optional<Boolean> offCycle;

    /**
     * The off-cycle reason. Only included for off-cycle payrolls.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("off_cycle_reason")
    private JsonNullable<? extends OffCycleReasonType> offCycleReason;

    /**
     * Indicates whether the payroll is an auto pilot payroll
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("auto_pilot")
    private Optional<Boolean> autoPilot;

    /**
     * Indicates whether the payroll is an external payroll
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("external")
    private Optional<Boolean> external;

    /**
     * Indicates whether the payroll is the final payroll for a terminated employee. Only included for off-cycle payrolls.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("final_termination_payroll")
    private Optional<Boolean> finalTerminationPayroll;

    /**
     * The payment schedule tax rate the payroll is based on. Only included for off-cycle payrolls.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("withholding_pay_period")
    private Optional<? extends PayrollWithholdingPayPeriodType> withholdingPayPeriod;

    /**
     * Block regular deductions and contributions for this payroll.  Only included for off-cycle payrolls.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("skip_regular_deductions")
    private Optional<Boolean> skipRegularDeductions;

    /**
     * Enable taxes to be withheld at the IRS's required rate of 22% for federal income taxes. State income taxes will be taxed at the state's supplemental tax rate. Otherwise, we'll sum the entirety of the employee's wages and withhold taxes on the entire amount at the rate for regular wages. Only included for off-cycle payrolls.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("fixed_withholding_rate")
    private Optional<Boolean> fixedWithholdingRate;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("pay_period")
    private Optional<? extends PayrollPayPeriodType> payPeriod;

    /**
     * Information about the payroll's status and expected dates
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("payroll_status_meta")
    private Optional<? extends PayrollPayrollStatusMetaType> payrollStatusMeta;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("employee_compensations")
    private Optional<? extends List<PayrollEmployeeCompensationsType>> employeeCompensations;

    /**
     * Only applicable when a payroll is moved to four day processing instead of fast ach.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("payment_speed_changed")
    private Optional<? extends PayrollPaymentSpeedChangedType> paymentSpeedChanged;

    /**
     * Datetime for when the resource was created.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("created_at")
    private Optional<OffsetDateTime> createdAt;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("fixed_compensation_types")
    private Optional<? extends List<PayrollFixedCompensationTypesType>> fixedCompensationTypes;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("processing_request")
    private JsonNullable<? extends PayrollProcessingRequest> processingRequest;

    @JsonCreator
    public PayrollPrepared(
            @JsonProperty("payroll_deadline") Optional<OffsetDateTime> payrollDeadline,
            @JsonProperty("check_date") Optional<String> checkDate,
            @JsonProperty("processed") Optional<Boolean> processed,
            @JsonProperty("processed_date") Optional<String> processedDate,
            @JsonProperty("calculated_at") Optional<String> calculatedAt,
            @JsonProperty("uuid") Optional<String> uuid,
            @JsonProperty("payroll_uuid") Optional<String> payrollUuid,
            @JsonProperty("company_uuid") Optional<String> companyUuid,
            @JsonProperty("off_cycle") Optional<Boolean> offCycle,
            @JsonProperty("off_cycle_reason") JsonNullable<? extends OffCycleReasonType> offCycleReason,
            @JsonProperty("auto_pilot") Optional<Boolean> autoPilot,
            @JsonProperty("external") Optional<Boolean> external,
            @JsonProperty("final_termination_payroll") Optional<Boolean> finalTerminationPayroll,
            @JsonProperty("withholding_pay_period") Optional<? extends PayrollWithholdingPayPeriodType> withholdingPayPeriod,
            @JsonProperty("skip_regular_deductions") Optional<Boolean> skipRegularDeductions,
            @JsonProperty("fixed_withholding_rate") Optional<Boolean> fixedWithholdingRate,
            @JsonProperty("pay_period") Optional<? extends PayrollPayPeriodType> payPeriod,
            @JsonProperty("payroll_status_meta") Optional<? extends PayrollPayrollStatusMetaType> payrollStatusMeta,
            @JsonProperty("employee_compensations") Optional<? extends List<PayrollEmployeeCompensationsType>> employeeCompensations,
            @JsonProperty("payment_speed_changed") Optional<? extends PayrollPaymentSpeedChangedType> paymentSpeedChanged,
            @JsonProperty("created_at") Optional<OffsetDateTime> createdAt,
            @JsonProperty("fixed_compensation_types") Optional<? extends List<PayrollFixedCompensationTypesType>> fixedCompensationTypes,
            @JsonProperty("processing_request") JsonNullable<? extends PayrollProcessingRequest> processingRequest) {
        Utils.checkNotNull(payrollDeadline, "payrollDeadline");
        Utils.checkNotNull(checkDate, "checkDate");
        Utils.checkNotNull(processed, "processed");
        Utils.checkNotNull(processedDate, "processedDate");
        Utils.checkNotNull(calculatedAt, "calculatedAt");
        Utils.checkNotNull(uuid, "uuid");
        Utils.checkNotNull(payrollUuid, "payrollUuid");
        Utils.checkNotNull(companyUuid, "companyUuid");
        Utils.checkNotNull(offCycle, "offCycle");
        Utils.checkNotNull(offCycleReason, "offCycleReason");
        Utils.checkNotNull(autoPilot, "autoPilot");
        Utils.checkNotNull(external, "external");
        Utils.checkNotNull(finalTerminationPayroll, "finalTerminationPayroll");
        Utils.checkNotNull(withholdingPayPeriod, "withholdingPayPeriod");
        Utils.checkNotNull(skipRegularDeductions, "skipRegularDeductions");
        Utils.checkNotNull(fixedWithholdingRate, "fixedWithholdingRate");
        Utils.checkNotNull(payPeriod, "payPeriod");
        Utils.checkNotNull(payrollStatusMeta, "payrollStatusMeta");
        Utils.checkNotNull(employeeCompensations, "employeeCompensations");
        Utils.checkNotNull(paymentSpeedChanged, "paymentSpeedChanged");
        Utils.checkNotNull(createdAt, "createdAt");
        Utils.checkNotNull(fixedCompensationTypes, "fixedCompensationTypes");
        Utils.checkNotNull(processingRequest, "processingRequest");
        this.payrollDeadline = payrollDeadline;
        this.checkDate = checkDate;
        this.processed = processed;
        this.processedDate = processedDate;
        this.calculatedAt = calculatedAt;
        this.uuid = uuid;
        this.payrollUuid = payrollUuid;
        this.companyUuid = companyUuid;
        this.offCycle = offCycle;
        this.offCycleReason = offCycleReason;
        this.autoPilot = autoPilot;
        this.external = external;
        this.finalTerminationPayroll = finalTerminationPayroll;
        this.withholdingPayPeriod = withholdingPayPeriod;
        this.skipRegularDeductions = skipRegularDeductions;
        this.fixedWithholdingRate = fixedWithholdingRate;
        this.payPeriod = payPeriod;
        this.payrollStatusMeta = payrollStatusMeta;
        this.employeeCompensations = employeeCompensations;
        this.paymentSpeedChanged = paymentSpeedChanged;
        this.createdAt = createdAt;
        this.fixedCompensationTypes = fixedCompensationTypes;
        this.processingRequest = processingRequest;
    }
    
    public PayrollPrepared() {
        this(Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), JsonNullable.undefined(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), JsonNullable.undefined());
    }

    /**
     * A timestamp that is the deadline for the payroll to be run in order for employees to be paid on time.  If payroll has not been run by the deadline, a prepare request will update both the check date and deadline to reflect the soonest employees can be paid and the deadline by which the payroll must be run in order for said check date to be met.
     */
    @JsonIgnore
    public Optional<OffsetDateTime> payrollDeadline() {
        return payrollDeadline;
    }

    /**
     * The date on which employees will be paid for the payroll.
     */
    @JsonIgnore
    public Optional<String> checkDate() {
        return checkDate;
    }

    /**
     * Whether or not the payroll has been successfully processed. Note that processed payrolls cannot be updated. Additionally, a payroll is not guaranteed to be processed just because the payroll deadline has passed. Late payrolls are not uncommon. Conversely, users may choose to run payroll before the payroll deadline.
     */
    @JsonIgnore
    public Optional<Boolean> processed() {
        return processed;
    }

    /**
     * The date at which the payroll was processed. Null if the payroll isn't processed yet.
     */
    @JsonIgnore
    public Optional<String> processedDate() {
        return processedDate;
    }

    /**
     * A timestamp of the last valid payroll calculation. Null if there isn't a valid calculation.
     */
    @JsonIgnore
    public Optional<String> calculatedAt() {
        return calculatedAt;
    }

    /**
     * The UUID of the payroll.
     */
    @JsonIgnore
    public Optional<String> uuid() {
        return uuid;
    }

    /**
     * The UUID of the payroll.
     */
    @JsonIgnore
    public Optional<String> payrollUuid() {
        return payrollUuid;
    }

    /**
     * The UUID of the company for the payroll.
     */
    @JsonIgnore
    public Optional<String> companyUuid() {
        return companyUuid;
    }

    /**
     * Indicates whether the payroll is an off-cycle payroll
     */
    @JsonIgnore
    public Optional<Boolean> offCycle() {
        return offCycle;
    }

    /**
     * The off-cycle reason. Only included for off-cycle payrolls.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<OffCycleReasonType> offCycleReason() {
        return (JsonNullable<OffCycleReasonType>) offCycleReason;
    }

    /**
     * Indicates whether the payroll is an auto pilot payroll
     */
    @JsonIgnore
    public Optional<Boolean> autoPilot() {
        return autoPilot;
    }

    /**
     * Indicates whether the payroll is an external payroll
     */
    @JsonIgnore
    public Optional<Boolean> external() {
        return external;
    }

    /**
     * Indicates whether the payroll is the final payroll for a terminated employee. Only included for off-cycle payrolls.
     */
    @JsonIgnore
    public Optional<Boolean> finalTerminationPayroll() {
        return finalTerminationPayroll;
    }

    /**
     * The payment schedule tax rate the payroll is based on. Only included for off-cycle payrolls.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<PayrollWithholdingPayPeriodType> withholdingPayPeriod() {
        return (Optional<PayrollWithholdingPayPeriodType>) withholdingPayPeriod;
    }

    /**
     * Block regular deductions and contributions for this payroll.  Only included for off-cycle payrolls.
     */
    @JsonIgnore
    public Optional<Boolean> skipRegularDeductions() {
        return skipRegularDeductions;
    }

    /**
     * Enable taxes to be withheld at the IRS's required rate of 22% for federal income taxes. State income taxes will be taxed at the state's supplemental tax rate. Otherwise, we'll sum the entirety of the employee's wages and withhold taxes on the entire amount at the rate for regular wages. Only included for off-cycle payrolls.
     */
    @JsonIgnore
    public Optional<Boolean> fixedWithholdingRate() {
        return fixedWithholdingRate;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<PayrollPayPeriodType> payPeriod() {
        return (Optional<PayrollPayPeriodType>) payPeriod;
    }

    /**
     * Information about the payroll's status and expected dates
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<PayrollPayrollStatusMetaType> payrollStatusMeta() {
        return (Optional<PayrollPayrollStatusMetaType>) payrollStatusMeta;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<PayrollEmployeeCompensationsType>> employeeCompensations() {
        return (Optional<List<PayrollEmployeeCompensationsType>>) employeeCompensations;
    }

    /**
     * Only applicable when a payroll is moved to four day processing instead of fast ach.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<PayrollPaymentSpeedChangedType> paymentSpeedChanged() {
        return (Optional<PayrollPaymentSpeedChangedType>) paymentSpeedChanged;
    }

    /**
     * Datetime for when the resource was created.
     */
    @JsonIgnore
    public Optional<OffsetDateTime> createdAt() {
        return createdAt;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<PayrollFixedCompensationTypesType>> fixedCompensationTypes() {
        return (Optional<List<PayrollFixedCompensationTypesType>>) fixedCompensationTypes;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<PayrollProcessingRequest> processingRequest() {
        return (JsonNullable<PayrollProcessingRequest>) processingRequest;
    }

    public final static Builder builder() {
        return new Builder();
    }

    /**
     * A timestamp that is the deadline for the payroll to be run in order for employees to be paid on time.  If payroll has not been run by the deadline, a prepare request will update both the check date and deadline to reflect the soonest employees can be paid and the deadline by which the payroll must be run in order for said check date to be met.
     */
    public PayrollPrepared withPayrollDeadline(OffsetDateTime payrollDeadline) {
        Utils.checkNotNull(payrollDeadline, "payrollDeadline");
        this.payrollDeadline = Optional.ofNullable(payrollDeadline);
        return this;
    }

    /**
     * A timestamp that is the deadline for the payroll to be run in order for employees to be paid on time.  If payroll has not been run by the deadline, a prepare request will update both the check date and deadline to reflect the soonest employees can be paid and the deadline by which the payroll must be run in order for said check date to be met.
     */
    public PayrollPrepared withPayrollDeadline(Optional<OffsetDateTime> payrollDeadline) {
        Utils.checkNotNull(payrollDeadline, "payrollDeadline");
        this.payrollDeadline = payrollDeadline;
        return this;
    }

    /**
     * The date on which employees will be paid for the payroll.
     */
    public PayrollPrepared withCheckDate(String checkDate) {
        Utils.checkNotNull(checkDate, "checkDate");
        this.checkDate = Optional.ofNullable(checkDate);
        return this;
    }

    /**
     * The date on which employees will be paid for the payroll.
     */
    public PayrollPrepared withCheckDate(Optional<String> checkDate) {
        Utils.checkNotNull(checkDate, "checkDate");
        this.checkDate = checkDate;
        return this;
    }

    /**
     * Whether or not the payroll has been successfully processed. Note that processed payrolls cannot be updated. Additionally, a payroll is not guaranteed to be processed just because the payroll deadline has passed. Late payrolls are not uncommon. Conversely, users may choose to run payroll before the payroll deadline.
     */
    public PayrollPrepared withProcessed(boolean processed) {
        Utils.checkNotNull(processed, "processed");
        this.processed = Optional.ofNullable(processed);
        return this;
    }

    /**
     * Whether or not the payroll has been successfully processed. Note that processed payrolls cannot be updated. Additionally, a payroll is not guaranteed to be processed just because the payroll deadline has passed. Late payrolls are not uncommon. Conversely, users may choose to run payroll before the payroll deadline.
     */
    public PayrollPrepared withProcessed(Optional<Boolean> processed) {
        Utils.checkNotNull(processed, "processed");
        this.processed = processed;
        return this;
    }

    /**
     * The date at which the payroll was processed. Null if the payroll isn't processed yet.
     */
    public PayrollPrepared withProcessedDate(String processedDate) {
        Utils.checkNotNull(processedDate, "processedDate");
        this.processedDate = Optional.ofNullable(processedDate);
        return this;
    }

    /**
     * The date at which the payroll was processed. Null if the payroll isn't processed yet.
     */
    public PayrollPrepared withProcessedDate(Optional<String> processedDate) {
        Utils.checkNotNull(processedDate, "processedDate");
        this.processedDate = processedDate;
        return this;
    }

    /**
     * A timestamp of the last valid payroll calculation. Null if there isn't a valid calculation.
     */
    public PayrollPrepared withCalculatedAt(String calculatedAt) {
        Utils.checkNotNull(calculatedAt, "calculatedAt");
        this.calculatedAt = Optional.ofNullable(calculatedAt);
        return this;
    }

    /**
     * A timestamp of the last valid payroll calculation. Null if there isn't a valid calculation.
     */
    public PayrollPrepared withCalculatedAt(Optional<String> calculatedAt) {
        Utils.checkNotNull(calculatedAt, "calculatedAt");
        this.calculatedAt = calculatedAt;
        return this;
    }

    /**
     * The UUID of the payroll.
     */
    public PayrollPrepared withUuid(String uuid) {
        Utils.checkNotNull(uuid, "uuid");
        this.uuid = Optional.ofNullable(uuid);
        return this;
    }

    /**
     * The UUID of the payroll.
     */
    public PayrollPrepared withUuid(Optional<String> uuid) {
        Utils.checkNotNull(uuid, "uuid");
        this.uuid = uuid;
        return this;
    }

    /**
     * The UUID of the payroll.
     */
    public PayrollPrepared withPayrollUuid(String payrollUuid) {
        Utils.checkNotNull(payrollUuid, "payrollUuid");
        this.payrollUuid = Optional.ofNullable(payrollUuid);
        return this;
    }

    /**
     * The UUID of the payroll.
     */
    public PayrollPrepared withPayrollUuid(Optional<String> payrollUuid) {
        Utils.checkNotNull(payrollUuid, "payrollUuid");
        this.payrollUuid = payrollUuid;
        return this;
    }

    /**
     * The UUID of the company for the payroll.
     */
    public PayrollPrepared withCompanyUuid(String companyUuid) {
        Utils.checkNotNull(companyUuid, "companyUuid");
        this.companyUuid = Optional.ofNullable(companyUuid);
        return this;
    }

    /**
     * The UUID of the company for the payroll.
     */
    public PayrollPrepared withCompanyUuid(Optional<String> companyUuid) {
        Utils.checkNotNull(companyUuid, "companyUuid");
        this.companyUuid = companyUuid;
        return this;
    }

    /**
     * Indicates whether the payroll is an off-cycle payroll
     */
    public PayrollPrepared withOffCycle(boolean offCycle) {
        Utils.checkNotNull(offCycle, "offCycle");
        this.offCycle = Optional.ofNullable(offCycle);
        return this;
    }

    /**
     * Indicates whether the payroll is an off-cycle payroll
     */
    public PayrollPrepared withOffCycle(Optional<Boolean> offCycle) {
        Utils.checkNotNull(offCycle, "offCycle");
        this.offCycle = offCycle;
        return this;
    }

    /**
     * The off-cycle reason. Only included for off-cycle payrolls.
     */
    public PayrollPrepared withOffCycleReason(OffCycleReasonType offCycleReason) {
        Utils.checkNotNull(offCycleReason, "offCycleReason");
        this.offCycleReason = JsonNullable.of(offCycleReason);
        return this;
    }

    /**
     * The off-cycle reason. Only included for off-cycle payrolls.
     */
    public PayrollPrepared withOffCycleReason(JsonNullable<? extends OffCycleReasonType> offCycleReason) {
        Utils.checkNotNull(offCycleReason, "offCycleReason");
        this.offCycleReason = offCycleReason;
        return this;
    }

    /**
     * Indicates whether the payroll is an auto pilot payroll
     */
    public PayrollPrepared withAutoPilot(boolean autoPilot) {
        Utils.checkNotNull(autoPilot, "autoPilot");
        this.autoPilot = Optional.ofNullable(autoPilot);
        return this;
    }

    /**
     * Indicates whether the payroll is an auto pilot payroll
     */
    public PayrollPrepared withAutoPilot(Optional<Boolean> autoPilot) {
        Utils.checkNotNull(autoPilot, "autoPilot");
        this.autoPilot = autoPilot;
        return this;
    }

    /**
     * Indicates whether the payroll is an external payroll
     */
    public PayrollPrepared withExternal(boolean external) {
        Utils.checkNotNull(external, "external");
        this.external = Optional.ofNullable(external);
        return this;
    }

    /**
     * Indicates whether the payroll is an external payroll
     */
    public PayrollPrepared withExternal(Optional<Boolean> external) {
        Utils.checkNotNull(external, "external");
        this.external = external;
        return this;
    }

    /**
     * Indicates whether the payroll is the final payroll for a terminated employee. Only included for off-cycle payrolls.
     */
    public PayrollPrepared withFinalTerminationPayroll(boolean finalTerminationPayroll) {
        Utils.checkNotNull(finalTerminationPayroll, "finalTerminationPayroll");
        this.finalTerminationPayroll = Optional.ofNullable(finalTerminationPayroll);
        return this;
    }

    /**
     * Indicates whether the payroll is the final payroll for a terminated employee. Only included for off-cycle payrolls.
     */
    public PayrollPrepared withFinalTerminationPayroll(Optional<Boolean> finalTerminationPayroll) {
        Utils.checkNotNull(finalTerminationPayroll, "finalTerminationPayroll");
        this.finalTerminationPayroll = finalTerminationPayroll;
        return this;
    }

    /**
     * The payment schedule tax rate the payroll is based on. Only included for off-cycle payrolls.
     */
    public PayrollPrepared withWithholdingPayPeriod(PayrollWithholdingPayPeriodType withholdingPayPeriod) {
        Utils.checkNotNull(withholdingPayPeriod, "withholdingPayPeriod");
        this.withholdingPayPeriod = Optional.ofNullable(withholdingPayPeriod);
        return this;
    }

    /**
     * The payment schedule tax rate the payroll is based on. Only included for off-cycle payrolls.
     */
    public PayrollPrepared withWithholdingPayPeriod(Optional<? extends PayrollWithholdingPayPeriodType> withholdingPayPeriod) {
        Utils.checkNotNull(withholdingPayPeriod, "withholdingPayPeriod");
        this.withholdingPayPeriod = withholdingPayPeriod;
        return this;
    }

    /**
     * Block regular deductions and contributions for this payroll.  Only included for off-cycle payrolls.
     */
    public PayrollPrepared withSkipRegularDeductions(boolean skipRegularDeductions) {
        Utils.checkNotNull(skipRegularDeductions, "skipRegularDeductions");
        this.skipRegularDeductions = Optional.ofNullable(skipRegularDeductions);
        return this;
    }

    /**
     * Block regular deductions and contributions for this payroll.  Only included for off-cycle payrolls.
     */
    public PayrollPrepared withSkipRegularDeductions(Optional<Boolean> skipRegularDeductions) {
        Utils.checkNotNull(skipRegularDeductions, "skipRegularDeductions");
        this.skipRegularDeductions = skipRegularDeductions;
        return this;
    }

    /**
     * Enable taxes to be withheld at the IRS's required rate of 22% for federal income taxes. State income taxes will be taxed at the state's supplemental tax rate. Otherwise, we'll sum the entirety of the employee's wages and withhold taxes on the entire amount at the rate for regular wages. Only included for off-cycle payrolls.
     */
    public PayrollPrepared withFixedWithholdingRate(boolean fixedWithholdingRate) {
        Utils.checkNotNull(fixedWithholdingRate, "fixedWithholdingRate");
        this.fixedWithholdingRate = Optional.ofNullable(fixedWithholdingRate);
        return this;
    }

    /**
     * Enable taxes to be withheld at the IRS's required rate of 22% for federal income taxes. State income taxes will be taxed at the state's supplemental tax rate. Otherwise, we'll sum the entirety of the employee's wages and withhold taxes on the entire amount at the rate for regular wages. Only included for off-cycle payrolls.
     */
    public PayrollPrepared withFixedWithholdingRate(Optional<Boolean> fixedWithholdingRate) {
        Utils.checkNotNull(fixedWithholdingRate, "fixedWithholdingRate");
        this.fixedWithholdingRate = fixedWithholdingRate;
        return this;
    }

    public PayrollPrepared withPayPeriod(PayrollPayPeriodType payPeriod) {
        Utils.checkNotNull(payPeriod, "payPeriod");
        this.payPeriod = Optional.ofNullable(payPeriod);
        return this;
    }

    public PayrollPrepared withPayPeriod(Optional<? extends PayrollPayPeriodType> payPeriod) {
        Utils.checkNotNull(payPeriod, "payPeriod");
        this.payPeriod = payPeriod;
        return this;
    }

    /**
     * Information about the payroll's status and expected dates
     */
    public PayrollPrepared withPayrollStatusMeta(PayrollPayrollStatusMetaType payrollStatusMeta) {
        Utils.checkNotNull(payrollStatusMeta, "payrollStatusMeta");
        this.payrollStatusMeta = Optional.ofNullable(payrollStatusMeta);
        return this;
    }

    /**
     * Information about the payroll's status and expected dates
     */
    public PayrollPrepared withPayrollStatusMeta(Optional<? extends PayrollPayrollStatusMetaType> payrollStatusMeta) {
        Utils.checkNotNull(payrollStatusMeta, "payrollStatusMeta");
        this.payrollStatusMeta = payrollStatusMeta;
        return this;
    }

    public PayrollPrepared withEmployeeCompensations(List<PayrollEmployeeCompensationsType> employeeCompensations) {
        Utils.checkNotNull(employeeCompensations, "employeeCompensations");
        this.employeeCompensations = Optional.ofNullable(employeeCompensations);
        return this;
    }

    public PayrollPrepared withEmployeeCompensations(Optional<? extends List<PayrollEmployeeCompensationsType>> employeeCompensations) {
        Utils.checkNotNull(employeeCompensations, "employeeCompensations");
        this.employeeCompensations = employeeCompensations;
        return this;
    }

    /**
     * Only applicable when a payroll is moved to four day processing instead of fast ach.
     */
    public PayrollPrepared withPaymentSpeedChanged(PayrollPaymentSpeedChangedType paymentSpeedChanged) {
        Utils.checkNotNull(paymentSpeedChanged, "paymentSpeedChanged");
        this.paymentSpeedChanged = Optional.ofNullable(paymentSpeedChanged);
        return this;
    }

    /**
     * Only applicable when a payroll is moved to four day processing instead of fast ach.
     */
    public PayrollPrepared withPaymentSpeedChanged(Optional<? extends PayrollPaymentSpeedChangedType> paymentSpeedChanged) {
        Utils.checkNotNull(paymentSpeedChanged, "paymentSpeedChanged");
        this.paymentSpeedChanged = paymentSpeedChanged;
        return this;
    }

    /**
     * Datetime for when the resource was created.
     */
    public PayrollPrepared withCreatedAt(OffsetDateTime createdAt) {
        Utils.checkNotNull(createdAt, "createdAt");
        this.createdAt = Optional.ofNullable(createdAt);
        return this;
    }

    /**
     * Datetime for when the resource was created.
     */
    public PayrollPrepared withCreatedAt(Optional<OffsetDateTime> createdAt) {
        Utils.checkNotNull(createdAt, "createdAt");
        this.createdAt = createdAt;
        return this;
    }

    public PayrollPrepared withFixedCompensationTypes(List<PayrollFixedCompensationTypesType> fixedCompensationTypes) {
        Utils.checkNotNull(fixedCompensationTypes, "fixedCompensationTypes");
        this.fixedCompensationTypes = Optional.ofNullable(fixedCompensationTypes);
        return this;
    }

    public PayrollPrepared withFixedCompensationTypes(Optional<? extends List<PayrollFixedCompensationTypesType>> fixedCompensationTypes) {
        Utils.checkNotNull(fixedCompensationTypes, "fixedCompensationTypes");
        this.fixedCompensationTypes = fixedCompensationTypes;
        return this;
    }

    public PayrollPrepared withProcessingRequest(PayrollProcessingRequest processingRequest) {
        Utils.checkNotNull(processingRequest, "processingRequest");
        this.processingRequest = JsonNullable.of(processingRequest);
        return this;
    }

    public PayrollPrepared withProcessingRequest(JsonNullable<? extends PayrollProcessingRequest> processingRequest) {
        Utils.checkNotNull(processingRequest, "processingRequest");
        this.processingRequest = processingRequest;
        return this;
    }
    
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        PayrollPrepared other = (PayrollPrepared) o;
        return 
            Objects.deepEquals(this.payrollDeadline, other.payrollDeadline) &&
            Objects.deepEquals(this.checkDate, other.checkDate) &&
            Objects.deepEquals(this.processed, other.processed) &&
            Objects.deepEquals(this.processedDate, other.processedDate) &&
            Objects.deepEquals(this.calculatedAt, other.calculatedAt) &&
            Objects.deepEquals(this.uuid, other.uuid) &&
            Objects.deepEquals(this.payrollUuid, other.payrollUuid) &&
            Objects.deepEquals(this.companyUuid, other.companyUuid) &&
            Objects.deepEquals(this.offCycle, other.offCycle) &&
            Objects.deepEquals(this.offCycleReason, other.offCycleReason) &&
            Objects.deepEquals(this.autoPilot, other.autoPilot) &&
            Objects.deepEquals(this.external, other.external) &&
            Objects.deepEquals(this.finalTerminationPayroll, other.finalTerminationPayroll) &&
            Objects.deepEquals(this.withholdingPayPeriod, other.withholdingPayPeriod) &&
            Objects.deepEquals(this.skipRegularDeductions, other.skipRegularDeductions) &&
            Objects.deepEquals(this.fixedWithholdingRate, other.fixedWithholdingRate) &&
            Objects.deepEquals(this.payPeriod, other.payPeriod) &&
            Objects.deepEquals(this.payrollStatusMeta, other.payrollStatusMeta) &&
            Objects.deepEquals(this.employeeCompensations, other.employeeCompensations) &&
            Objects.deepEquals(this.paymentSpeedChanged, other.paymentSpeedChanged) &&
            Objects.deepEquals(this.createdAt, other.createdAt) &&
            Objects.deepEquals(this.fixedCompensationTypes, other.fixedCompensationTypes) &&
            Objects.deepEquals(this.processingRequest, other.processingRequest);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(
            payrollDeadline,
            checkDate,
            processed,
            processedDate,
            calculatedAt,
            uuid,
            payrollUuid,
            companyUuid,
            offCycle,
            offCycleReason,
            autoPilot,
            external,
            finalTerminationPayroll,
            withholdingPayPeriod,
            skipRegularDeductions,
            fixedWithholdingRate,
            payPeriod,
            payrollStatusMeta,
            employeeCompensations,
            paymentSpeedChanged,
            createdAt,
            fixedCompensationTypes,
            processingRequest);
    }
    
    @Override
    public String toString() {
        return Utils.toString(PayrollPrepared.class,
                "payrollDeadline", payrollDeadline,
                "checkDate", checkDate,
                "processed", processed,
                "processedDate", processedDate,
                "calculatedAt", calculatedAt,
                "uuid", uuid,
                "payrollUuid", payrollUuid,
                "companyUuid", companyUuid,
                "offCycle", offCycle,
                "offCycleReason", offCycleReason,
                "autoPilot", autoPilot,
                "external", external,
                "finalTerminationPayroll", finalTerminationPayroll,
                "withholdingPayPeriod", withholdingPayPeriod,
                "skipRegularDeductions", skipRegularDeductions,
                "fixedWithholdingRate", fixedWithholdingRate,
                "payPeriod", payPeriod,
                "payrollStatusMeta", payrollStatusMeta,
                "employeeCompensations", employeeCompensations,
                "paymentSpeedChanged", paymentSpeedChanged,
                "createdAt", createdAt,
                "fixedCompensationTypes", fixedCompensationTypes,
                "processingRequest", processingRequest);
    }
    
    public final static class Builder {
 
        private Optional<OffsetDateTime> payrollDeadline = Optional.empty();
 
        private Optional<String> checkDate = Optional.empty();
 
        private Optional<Boolean> processed = Optional.empty();
 
        private Optional<String> processedDate = Optional.empty();
 
        private Optional<String> calculatedAt = Optional.empty();
 
        private Optional<String> uuid = Optional.empty();
 
        private Optional<String> payrollUuid = Optional.empty();
 
        private Optional<String> companyUuid = Optional.empty();
 
        private Optional<Boolean> offCycle = Optional.empty();
 
        private JsonNullable<? extends OffCycleReasonType> offCycleReason = JsonNullable.undefined();
 
        private Optional<Boolean> autoPilot = Optional.empty();
 
        private Optional<Boolean> external = Optional.empty();
 
        private Optional<Boolean> finalTerminationPayroll = Optional.empty();
 
        private Optional<? extends PayrollWithholdingPayPeriodType> withholdingPayPeriod = Optional.empty();
 
        private Optional<Boolean> skipRegularDeductions = Optional.empty();
 
        private Optional<Boolean> fixedWithholdingRate = Optional.empty();
 
        private Optional<? extends PayrollPayPeriodType> payPeriod = Optional.empty();
 
        private Optional<? extends PayrollPayrollStatusMetaType> payrollStatusMeta = Optional.empty();
 
        private Optional<? extends List<PayrollEmployeeCompensationsType>> employeeCompensations = Optional.empty();
 
        private Optional<? extends PayrollPaymentSpeedChangedType> paymentSpeedChanged = Optional.empty();
 
        private Optional<OffsetDateTime> createdAt = Optional.empty();
 
        private Optional<? extends List<PayrollFixedCompensationTypesType>> fixedCompensationTypes = Optional.empty();
 
        private JsonNullable<? extends PayrollProcessingRequest> processingRequest = JsonNullable.undefined();  
        
        private Builder() {
          // force use of static builder() method
        }

        /**
         * A timestamp that is the deadline for the payroll to be run in order for employees to be paid on time.  If payroll has not been run by the deadline, a prepare request will update both the check date and deadline to reflect the soonest employees can be paid and the deadline by which the payroll must be run in order for said check date to be met.
         */
        public Builder payrollDeadline(OffsetDateTime payrollDeadline) {
            Utils.checkNotNull(payrollDeadline, "payrollDeadline");
            this.payrollDeadline = Optional.ofNullable(payrollDeadline);
            return this;
        }

        /**
         * A timestamp that is the deadline for the payroll to be run in order for employees to be paid on time.  If payroll has not been run by the deadline, a prepare request will update both the check date and deadline to reflect the soonest employees can be paid and the deadline by which the payroll must be run in order for said check date to be met.
         */
        public Builder payrollDeadline(Optional<OffsetDateTime> payrollDeadline) {
            Utils.checkNotNull(payrollDeadline, "payrollDeadline");
            this.payrollDeadline = payrollDeadline;
            return this;
        }

        /**
         * The date on which employees will be paid for the payroll.
         */
        public Builder checkDate(String checkDate) {
            Utils.checkNotNull(checkDate, "checkDate");
            this.checkDate = Optional.ofNullable(checkDate);
            return this;
        }

        /**
         * The date on which employees will be paid for the payroll.
         */
        public Builder checkDate(Optional<String> checkDate) {
            Utils.checkNotNull(checkDate, "checkDate");
            this.checkDate = checkDate;
            return this;
        }

        /**
         * Whether or not the payroll has been successfully processed. Note that processed payrolls cannot be updated. Additionally, a payroll is not guaranteed to be processed just because the payroll deadline has passed. Late payrolls are not uncommon. Conversely, users may choose to run payroll before the payroll deadline.
         */
        public Builder processed(boolean processed) {
            Utils.checkNotNull(processed, "processed");
            this.processed = Optional.ofNullable(processed);
            return this;
        }

        /**
         * Whether or not the payroll has been successfully processed. Note that processed payrolls cannot be updated. Additionally, a payroll is not guaranteed to be processed just because the payroll deadline has passed. Late payrolls are not uncommon. Conversely, users may choose to run payroll before the payroll deadline.
         */
        public Builder processed(Optional<Boolean> processed) {
            Utils.checkNotNull(processed, "processed");
            this.processed = processed;
            return this;
        }

        /**
         * The date at which the payroll was processed. Null if the payroll isn't processed yet.
         */
        public Builder processedDate(String processedDate) {
            Utils.checkNotNull(processedDate, "processedDate");
            this.processedDate = Optional.ofNullable(processedDate);
            return this;
        }

        /**
         * The date at which the payroll was processed. Null if the payroll isn't processed yet.
         */
        public Builder processedDate(Optional<String> processedDate) {
            Utils.checkNotNull(processedDate, "processedDate");
            this.processedDate = processedDate;
            return this;
        }

        /**
         * A timestamp of the last valid payroll calculation. Null if there isn't a valid calculation.
         */
        public Builder calculatedAt(String calculatedAt) {
            Utils.checkNotNull(calculatedAt, "calculatedAt");
            this.calculatedAt = Optional.ofNullable(calculatedAt);
            return this;
        }

        /**
         * A timestamp of the last valid payroll calculation. Null if there isn't a valid calculation.
         */
        public Builder calculatedAt(Optional<String> calculatedAt) {
            Utils.checkNotNull(calculatedAt, "calculatedAt");
            this.calculatedAt = calculatedAt;
            return this;
        }

        /**
         * The UUID of the payroll.
         */
        public Builder uuid(String uuid) {
            Utils.checkNotNull(uuid, "uuid");
            this.uuid = Optional.ofNullable(uuid);
            return this;
        }

        /**
         * The UUID of the payroll.
         */
        public Builder uuid(Optional<String> uuid) {
            Utils.checkNotNull(uuid, "uuid");
            this.uuid = uuid;
            return this;
        }

        /**
         * The UUID of the payroll.
         */
        public Builder payrollUuid(String payrollUuid) {
            Utils.checkNotNull(payrollUuid, "payrollUuid");
            this.payrollUuid = Optional.ofNullable(payrollUuid);
            return this;
        }

        /**
         * The UUID of the payroll.
         */
        public Builder payrollUuid(Optional<String> payrollUuid) {
            Utils.checkNotNull(payrollUuid, "payrollUuid");
            this.payrollUuid = payrollUuid;
            return this;
        }

        /**
         * The UUID of the company for the payroll.
         */
        public Builder companyUuid(String companyUuid) {
            Utils.checkNotNull(companyUuid, "companyUuid");
            this.companyUuid = Optional.ofNullable(companyUuid);
            return this;
        }

        /**
         * The UUID of the company for the payroll.
         */
        public Builder companyUuid(Optional<String> companyUuid) {
            Utils.checkNotNull(companyUuid, "companyUuid");
            this.companyUuid = companyUuid;
            return this;
        }

        /**
         * Indicates whether the payroll is an off-cycle payroll
         */
        public Builder offCycle(boolean offCycle) {
            Utils.checkNotNull(offCycle, "offCycle");
            this.offCycle = Optional.ofNullable(offCycle);
            return this;
        }

        /**
         * Indicates whether the payroll is an off-cycle payroll
         */
        public Builder offCycle(Optional<Boolean> offCycle) {
            Utils.checkNotNull(offCycle, "offCycle");
            this.offCycle = offCycle;
            return this;
        }

        /**
         * The off-cycle reason. Only included for off-cycle payrolls.
         */
        public Builder offCycleReason(OffCycleReasonType offCycleReason) {
            Utils.checkNotNull(offCycleReason, "offCycleReason");
            this.offCycleReason = JsonNullable.of(offCycleReason);
            return this;
        }

        /**
         * The off-cycle reason. Only included for off-cycle payrolls.
         */
        public Builder offCycleReason(JsonNullable<? extends OffCycleReasonType> offCycleReason) {
            Utils.checkNotNull(offCycleReason, "offCycleReason");
            this.offCycleReason = offCycleReason;
            return this;
        }

        /**
         * Indicates whether the payroll is an auto pilot payroll
         */
        public Builder autoPilot(boolean autoPilot) {
            Utils.checkNotNull(autoPilot, "autoPilot");
            this.autoPilot = Optional.ofNullable(autoPilot);
            return this;
        }

        /**
         * Indicates whether the payroll is an auto pilot payroll
         */
        public Builder autoPilot(Optional<Boolean> autoPilot) {
            Utils.checkNotNull(autoPilot, "autoPilot");
            this.autoPilot = autoPilot;
            return this;
        }

        /**
         * Indicates whether the payroll is an external payroll
         */
        public Builder external(boolean external) {
            Utils.checkNotNull(external, "external");
            this.external = Optional.ofNullable(external);
            return this;
        }

        /**
         * Indicates whether the payroll is an external payroll
         */
        public Builder external(Optional<Boolean> external) {
            Utils.checkNotNull(external, "external");
            this.external = external;
            return this;
        }

        /**
         * Indicates whether the payroll is the final payroll for a terminated employee. Only included for off-cycle payrolls.
         */
        public Builder finalTerminationPayroll(boolean finalTerminationPayroll) {
            Utils.checkNotNull(finalTerminationPayroll, "finalTerminationPayroll");
            this.finalTerminationPayroll = Optional.ofNullable(finalTerminationPayroll);
            return this;
        }

        /**
         * Indicates whether the payroll is the final payroll for a terminated employee. Only included for off-cycle payrolls.
         */
        public Builder finalTerminationPayroll(Optional<Boolean> finalTerminationPayroll) {
            Utils.checkNotNull(finalTerminationPayroll, "finalTerminationPayroll");
            this.finalTerminationPayroll = finalTerminationPayroll;
            return this;
        }

        /**
         * The payment schedule tax rate the payroll is based on. Only included for off-cycle payrolls.
         */
        public Builder withholdingPayPeriod(PayrollWithholdingPayPeriodType withholdingPayPeriod) {
            Utils.checkNotNull(withholdingPayPeriod, "withholdingPayPeriod");
            this.withholdingPayPeriod = Optional.ofNullable(withholdingPayPeriod);
            return this;
        }

        /**
         * The payment schedule tax rate the payroll is based on. Only included for off-cycle payrolls.
         */
        public Builder withholdingPayPeriod(Optional<? extends PayrollWithholdingPayPeriodType> withholdingPayPeriod) {
            Utils.checkNotNull(withholdingPayPeriod, "withholdingPayPeriod");
            this.withholdingPayPeriod = withholdingPayPeriod;
            return this;
        }

        /**
         * Block regular deductions and contributions for this payroll.  Only included for off-cycle payrolls.
         */
        public Builder skipRegularDeductions(boolean skipRegularDeductions) {
            Utils.checkNotNull(skipRegularDeductions, "skipRegularDeductions");
            this.skipRegularDeductions = Optional.ofNullable(skipRegularDeductions);
            return this;
        }

        /**
         * Block regular deductions and contributions for this payroll.  Only included for off-cycle payrolls.
         */
        public Builder skipRegularDeductions(Optional<Boolean> skipRegularDeductions) {
            Utils.checkNotNull(skipRegularDeductions, "skipRegularDeductions");
            this.skipRegularDeductions = skipRegularDeductions;
            return this;
        }

        /**
         * Enable taxes to be withheld at the IRS's required rate of 22% for federal income taxes. State income taxes will be taxed at the state's supplemental tax rate. Otherwise, we'll sum the entirety of the employee's wages and withhold taxes on the entire amount at the rate for regular wages. Only included for off-cycle payrolls.
         */
        public Builder fixedWithholdingRate(boolean fixedWithholdingRate) {
            Utils.checkNotNull(fixedWithholdingRate, "fixedWithholdingRate");
            this.fixedWithholdingRate = Optional.ofNullable(fixedWithholdingRate);
            return this;
        }

        /**
         * Enable taxes to be withheld at the IRS's required rate of 22% for federal income taxes. State income taxes will be taxed at the state's supplemental tax rate. Otherwise, we'll sum the entirety of the employee's wages and withhold taxes on the entire amount at the rate for regular wages. Only included for off-cycle payrolls.
         */
        public Builder fixedWithholdingRate(Optional<Boolean> fixedWithholdingRate) {
            Utils.checkNotNull(fixedWithholdingRate, "fixedWithholdingRate");
            this.fixedWithholdingRate = fixedWithholdingRate;
            return this;
        }

        public Builder payPeriod(PayrollPayPeriodType payPeriod) {
            Utils.checkNotNull(payPeriod, "payPeriod");
            this.payPeriod = Optional.ofNullable(payPeriod);
            return this;
        }

        public Builder payPeriod(Optional<? extends PayrollPayPeriodType> payPeriod) {
            Utils.checkNotNull(payPeriod, "payPeriod");
            this.payPeriod = payPeriod;
            return this;
        }

        /**
         * Information about the payroll's status and expected dates
         */
        public Builder payrollStatusMeta(PayrollPayrollStatusMetaType payrollStatusMeta) {
            Utils.checkNotNull(payrollStatusMeta, "payrollStatusMeta");
            this.payrollStatusMeta = Optional.ofNullable(payrollStatusMeta);
            return this;
        }

        /**
         * Information about the payroll's status and expected dates
         */
        public Builder payrollStatusMeta(Optional<? extends PayrollPayrollStatusMetaType> payrollStatusMeta) {
            Utils.checkNotNull(payrollStatusMeta, "payrollStatusMeta");
            this.payrollStatusMeta = payrollStatusMeta;
            return this;
        }

        public Builder employeeCompensations(List<PayrollEmployeeCompensationsType> employeeCompensations) {
            Utils.checkNotNull(employeeCompensations, "employeeCompensations");
            this.employeeCompensations = Optional.ofNullable(employeeCompensations);
            return this;
        }

        public Builder employeeCompensations(Optional<? extends List<PayrollEmployeeCompensationsType>> employeeCompensations) {
            Utils.checkNotNull(employeeCompensations, "employeeCompensations");
            this.employeeCompensations = employeeCompensations;
            return this;
        }

        /**
         * Only applicable when a payroll is moved to four day processing instead of fast ach.
         */
        public Builder paymentSpeedChanged(PayrollPaymentSpeedChangedType paymentSpeedChanged) {
            Utils.checkNotNull(paymentSpeedChanged, "paymentSpeedChanged");
            this.paymentSpeedChanged = Optional.ofNullable(paymentSpeedChanged);
            return this;
        }

        /**
         * Only applicable when a payroll is moved to four day processing instead of fast ach.
         */
        public Builder paymentSpeedChanged(Optional<? extends PayrollPaymentSpeedChangedType> paymentSpeedChanged) {
            Utils.checkNotNull(paymentSpeedChanged, "paymentSpeedChanged");
            this.paymentSpeedChanged = paymentSpeedChanged;
            return this;
        }

        /**
         * Datetime for when the resource was created.
         */
        public Builder createdAt(OffsetDateTime createdAt) {
            Utils.checkNotNull(createdAt, "createdAt");
            this.createdAt = Optional.ofNullable(createdAt);
            return this;
        }

        /**
         * Datetime for when the resource was created.
         */
        public Builder createdAt(Optional<OffsetDateTime> createdAt) {
            Utils.checkNotNull(createdAt, "createdAt");
            this.createdAt = createdAt;
            return this;
        }

        public Builder fixedCompensationTypes(List<PayrollFixedCompensationTypesType> fixedCompensationTypes) {
            Utils.checkNotNull(fixedCompensationTypes, "fixedCompensationTypes");
            this.fixedCompensationTypes = Optional.ofNullable(fixedCompensationTypes);
            return this;
        }

        public Builder fixedCompensationTypes(Optional<? extends List<PayrollFixedCompensationTypesType>> fixedCompensationTypes) {
            Utils.checkNotNull(fixedCompensationTypes, "fixedCompensationTypes");
            this.fixedCompensationTypes = fixedCompensationTypes;
            return this;
        }

        public Builder processingRequest(PayrollProcessingRequest processingRequest) {
            Utils.checkNotNull(processingRequest, "processingRequest");
            this.processingRequest = JsonNullable.of(processingRequest);
            return this;
        }

        public Builder processingRequest(JsonNullable<? extends PayrollProcessingRequest> processingRequest) {
            Utils.checkNotNull(processingRequest, "processingRequest");
            this.processingRequest = processingRequest;
            return this;
        }
        
        public PayrollPrepared build() {
            return new PayrollPrepared(
                payrollDeadline,
                checkDate,
                processed,
                processedDate,
                calculatedAt,
                uuid,
                payrollUuid,
                companyUuid,
                offCycle,
                offCycleReason,
                autoPilot,
                external,
                finalTerminationPayroll,
                withholdingPayPeriod,
                skipRegularDeductions,
                fixedWithholdingRate,
                payPeriod,
                payrollStatusMeta,
                employeeCompensations,
                paymentSpeedChanged,
                createdAt,
                fixedCompensationTypes,
                processingRequest);
        }
    }
}

