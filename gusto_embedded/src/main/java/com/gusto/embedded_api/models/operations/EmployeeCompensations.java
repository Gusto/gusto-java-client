/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

package com.gusto.embedded_api.models.operations;


import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.gusto.embedded_api.utils.Utils;
import java.lang.Boolean;
import java.lang.Override;
import java.lang.String;
import java.lang.SuppressWarnings;
import java.util.List;
import java.util.Objects;
import java.util.Optional;


public class EmployeeCompensations {

    /**
     * The UUID of the employee.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("employee_uuid")
    private Optional<String> employeeUuid;

    /**
     * The current version of this employee compensation from the prepared payroll. See the [versioning guide](https://docs.gusto.com/embedded-payroll/docs/idempotency) for information on how to use this field.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("version")
    private Optional<String> version;

    /**
     * This employee will be excluded from payroll calculation and will not be paid for the payroll.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("excluded")
    private Optional<Boolean> excluded;

    /**
     * The employee's compensation payment method. Invalid values will be ignored.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("payment_method")
    private Optional<? extends PaymentMethod> paymentMethod;

    /**
     * Custom text that will be printed as a personal note to the employee on a paystub.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("memo")
    private Optional<String> memo;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("fixed_compensations")
    private Optional<? extends List<FixedCompensations>> fixedCompensations;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("hourly_compensations")
    private Optional<? extends List<HourlyCompensations>> hourlyCompensations;

    /**
     * An array of all paid time off the employee is eligible for this pay period. Each paid time off object can be the name or the specific policy_uuid.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("paid_time_off")
    private Optional<? extends List<PaidTimeOff>> paidTimeOff;

    @JsonCreator
    public EmployeeCompensations(
            @JsonProperty("employee_uuid") Optional<String> employeeUuid,
            @JsonProperty("version") Optional<String> version,
            @JsonProperty("excluded") Optional<Boolean> excluded,
            @JsonProperty("payment_method") Optional<? extends PaymentMethod> paymentMethod,
            @JsonProperty("memo") Optional<String> memo,
            @JsonProperty("fixed_compensations") Optional<? extends List<FixedCompensations>> fixedCompensations,
            @JsonProperty("hourly_compensations") Optional<? extends List<HourlyCompensations>> hourlyCompensations,
            @JsonProperty("paid_time_off") Optional<? extends List<PaidTimeOff>> paidTimeOff) {
        Utils.checkNotNull(employeeUuid, "employeeUuid");
        Utils.checkNotNull(version, "version");
        Utils.checkNotNull(excluded, "excluded");
        Utils.checkNotNull(paymentMethod, "paymentMethod");
        Utils.checkNotNull(memo, "memo");
        Utils.checkNotNull(fixedCompensations, "fixedCompensations");
        Utils.checkNotNull(hourlyCompensations, "hourlyCompensations");
        Utils.checkNotNull(paidTimeOff, "paidTimeOff");
        this.employeeUuid = employeeUuid;
        this.version = version;
        this.excluded = excluded;
        this.paymentMethod = paymentMethod;
        this.memo = memo;
        this.fixedCompensations = fixedCompensations;
        this.hourlyCompensations = hourlyCompensations;
        this.paidTimeOff = paidTimeOff;
    }
    
    public EmployeeCompensations() {
        this(Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty());
    }

    /**
     * The UUID of the employee.
     */
    @JsonIgnore
    public Optional<String> employeeUuid() {
        return employeeUuid;
    }

    /**
     * The current version of this employee compensation from the prepared payroll. See the [versioning guide](https://docs.gusto.com/embedded-payroll/docs/idempotency) for information on how to use this field.
     */
    @JsonIgnore
    public Optional<String> version() {
        return version;
    }

    /**
     * This employee will be excluded from payroll calculation and will not be paid for the payroll.
     */
    @JsonIgnore
    public Optional<Boolean> excluded() {
        return excluded;
    }

    /**
     * The employee's compensation payment method. Invalid values will be ignored.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<PaymentMethod> paymentMethod() {
        return (Optional<PaymentMethod>) paymentMethod;
    }

    /**
     * Custom text that will be printed as a personal note to the employee on a paystub.
     */
    @JsonIgnore
    public Optional<String> memo() {
        return memo;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<FixedCompensations>> fixedCompensations() {
        return (Optional<List<FixedCompensations>>) fixedCompensations;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<HourlyCompensations>> hourlyCompensations() {
        return (Optional<List<HourlyCompensations>>) hourlyCompensations;
    }

    /**
     * An array of all paid time off the employee is eligible for this pay period. Each paid time off object can be the name or the specific policy_uuid.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<PaidTimeOff>> paidTimeOff() {
        return (Optional<List<PaidTimeOff>>) paidTimeOff;
    }

    public final static Builder builder() {
        return new Builder();
    }

    /**
     * The UUID of the employee.
     */
    public EmployeeCompensations withEmployeeUuid(String employeeUuid) {
        Utils.checkNotNull(employeeUuid, "employeeUuid");
        this.employeeUuid = Optional.ofNullable(employeeUuid);
        return this;
    }

    /**
     * The UUID of the employee.
     */
    public EmployeeCompensations withEmployeeUuid(Optional<String> employeeUuid) {
        Utils.checkNotNull(employeeUuid, "employeeUuid");
        this.employeeUuid = employeeUuid;
        return this;
    }

    /**
     * The current version of this employee compensation from the prepared payroll. See the [versioning guide](https://docs.gusto.com/embedded-payroll/docs/idempotency) for information on how to use this field.
     */
    public EmployeeCompensations withVersion(String version) {
        Utils.checkNotNull(version, "version");
        this.version = Optional.ofNullable(version);
        return this;
    }

    /**
     * The current version of this employee compensation from the prepared payroll. See the [versioning guide](https://docs.gusto.com/embedded-payroll/docs/idempotency) for information on how to use this field.
     */
    public EmployeeCompensations withVersion(Optional<String> version) {
        Utils.checkNotNull(version, "version");
        this.version = version;
        return this;
    }

    /**
     * This employee will be excluded from payroll calculation and will not be paid for the payroll.
     */
    public EmployeeCompensations withExcluded(boolean excluded) {
        Utils.checkNotNull(excluded, "excluded");
        this.excluded = Optional.ofNullable(excluded);
        return this;
    }

    /**
     * This employee will be excluded from payroll calculation and will not be paid for the payroll.
     */
    public EmployeeCompensations withExcluded(Optional<Boolean> excluded) {
        Utils.checkNotNull(excluded, "excluded");
        this.excluded = excluded;
        return this;
    }

    /**
     * The employee's compensation payment method. Invalid values will be ignored.
     */
    public EmployeeCompensations withPaymentMethod(PaymentMethod paymentMethod) {
        Utils.checkNotNull(paymentMethod, "paymentMethod");
        this.paymentMethod = Optional.ofNullable(paymentMethod);
        return this;
    }

    /**
     * The employee's compensation payment method. Invalid values will be ignored.
     */
    public EmployeeCompensations withPaymentMethod(Optional<? extends PaymentMethod> paymentMethod) {
        Utils.checkNotNull(paymentMethod, "paymentMethod");
        this.paymentMethod = paymentMethod;
        return this;
    }

    /**
     * Custom text that will be printed as a personal note to the employee on a paystub.
     */
    public EmployeeCompensations withMemo(String memo) {
        Utils.checkNotNull(memo, "memo");
        this.memo = Optional.ofNullable(memo);
        return this;
    }

    /**
     * Custom text that will be printed as a personal note to the employee on a paystub.
     */
    public EmployeeCompensations withMemo(Optional<String> memo) {
        Utils.checkNotNull(memo, "memo");
        this.memo = memo;
        return this;
    }

    public EmployeeCompensations withFixedCompensations(List<FixedCompensations> fixedCompensations) {
        Utils.checkNotNull(fixedCompensations, "fixedCompensations");
        this.fixedCompensations = Optional.ofNullable(fixedCompensations);
        return this;
    }

    public EmployeeCompensations withFixedCompensations(Optional<? extends List<FixedCompensations>> fixedCompensations) {
        Utils.checkNotNull(fixedCompensations, "fixedCompensations");
        this.fixedCompensations = fixedCompensations;
        return this;
    }

    public EmployeeCompensations withHourlyCompensations(List<HourlyCompensations> hourlyCompensations) {
        Utils.checkNotNull(hourlyCompensations, "hourlyCompensations");
        this.hourlyCompensations = Optional.ofNullable(hourlyCompensations);
        return this;
    }

    public EmployeeCompensations withHourlyCompensations(Optional<? extends List<HourlyCompensations>> hourlyCompensations) {
        Utils.checkNotNull(hourlyCompensations, "hourlyCompensations");
        this.hourlyCompensations = hourlyCompensations;
        return this;
    }

    /**
     * An array of all paid time off the employee is eligible for this pay period. Each paid time off object can be the name or the specific policy_uuid.
     */
    public EmployeeCompensations withPaidTimeOff(List<PaidTimeOff> paidTimeOff) {
        Utils.checkNotNull(paidTimeOff, "paidTimeOff");
        this.paidTimeOff = Optional.ofNullable(paidTimeOff);
        return this;
    }

    /**
     * An array of all paid time off the employee is eligible for this pay period. Each paid time off object can be the name or the specific policy_uuid.
     */
    public EmployeeCompensations withPaidTimeOff(Optional<? extends List<PaidTimeOff>> paidTimeOff) {
        Utils.checkNotNull(paidTimeOff, "paidTimeOff");
        this.paidTimeOff = paidTimeOff;
        return this;
    }
    
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        EmployeeCompensations other = (EmployeeCompensations) o;
        return 
            Objects.deepEquals(this.employeeUuid, other.employeeUuid) &&
            Objects.deepEquals(this.version, other.version) &&
            Objects.deepEquals(this.excluded, other.excluded) &&
            Objects.deepEquals(this.paymentMethod, other.paymentMethod) &&
            Objects.deepEquals(this.memo, other.memo) &&
            Objects.deepEquals(this.fixedCompensations, other.fixedCompensations) &&
            Objects.deepEquals(this.hourlyCompensations, other.hourlyCompensations) &&
            Objects.deepEquals(this.paidTimeOff, other.paidTimeOff);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(
            employeeUuid,
            version,
            excluded,
            paymentMethod,
            memo,
            fixedCompensations,
            hourlyCompensations,
            paidTimeOff);
    }
    
    @Override
    public String toString() {
        return Utils.toString(EmployeeCompensations.class,
                "employeeUuid", employeeUuid,
                "version", version,
                "excluded", excluded,
                "paymentMethod", paymentMethod,
                "memo", memo,
                "fixedCompensations", fixedCompensations,
                "hourlyCompensations", hourlyCompensations,
                "paidTimeOff", paidTimeOff);
    }
    
    public final static class Builder {
 
        private Optional<String> employeeUuid = Optional.empty();
 
        private Optional<String> version = Optional.empty();
 
        private Optional<Boolean> excluded = Optional.empty();
 
        private Optional<? extends PaymentMethod> paymentMethod = Optional.empty();
 
        private Optional<String> memo = Optional.empty();
 
        private Optional<? extends List<FixedCompensations>> fixedCompensations = Optional.empty();
 
        private Optional<? extends List<HourlyCompensations>> hourlyCompensations = Optional.empty();
 
        private Optional<? extends List<PaidTimeOff>> paidTimeOff = Optional.empty();  
        
        private Builder() {
          // force use of static builder() method
        }

        /**
         * The UUID of the employee.
         */
        public Builder employeeUuid(String employeeUuid) {
            Utils.checkNotNull(employeeUuid, "employeeUuid");
            this.employeeUuid = Optional.ofNullable(employeeUuid);
            return this;
        }

        /**
         * The UUID of the employee.
         */
        public Builder employeeUuid(Optional<String> employeeUuid) {
            Utils.checkNotNull(employeeUuid, "employeeUuid");
            this.employeeUuid = employeeUuid;
            return this;
        }

        /**
         * The current version of this employee compensation from the prepared payroll. See the [versioning guide](https://docs.gusto.com/embedded-payroll/docs/idempotency) for information on how to use this field.
         */
        public Builder version(String version) {
            Utils.checkNotNull(version, "version");
            this.version = Optional.ofNullable(version);
            return this;
        }

        /**
         * The current version of this employee compensation from the prepared payroll. See the [versioning guide](https://docs.gusto.com/embedded-payroll/docs/idempotency) for information on how to use this field.
         */
        public Builder version(Optional<String> version) {
            Utils.checkNotNull(version, "version");
            this.version = version;
            return this;
        }

        /**
         * This employee will be excluded from payroll calculation and will not be paid for the payroll.
         */
        public Builder excluded(boolean excluded) {
            Utils.checkNotNull(excluded, "excluded");
            this.excluded = Optional.ofNullable(excluded);
            return this;
        }

        /**
         * This employee will be excluded from payroll calculation and will not be paid for the payroll.
         */
        public Builder excluded(Optional<Boolean> excluded) {
            Utils.checkNotNull(excluded, "excluded");
            this.excluded = excluded;
            return this;
        }

        /**
         * The employee's compensation payment method. Invalid values will be ignored.
         */
        public Builder paymentMethod(PaymentMethod paymentMethod) {
            Utils.checkNotNull(paymentMethod, "paymentMethod");
            this.paymentMethod = Optional.ofNullable(paymentMethod);
            return this;
        }

        /**
         * The employee's compensation payment method. Invalid values will be ignored.
         */
        public Builder paymentMethod(Optional<? extends PaymentMethod> paymentMethod) {
            Utils.checkNotNull(paymentMethod, "paymentMethod");
            this.paymentMethod = paymentMethod;
            return this;
        }

        /**
         * Custom text that will be printed as a personal note to the employee on a paystub.
         */
        public Builder memo(String memo) {
            Utils.checkNotNull(memo, "memo");
            this.memo = Optional.ofNullable(memo);
            return this;
        }

        /**
         * Custom text that will be printed as a personal note to the employee on a paystub.
         */
        public Builder memo(Optional<String> memo) {
            Utils.checkNotNull(memo, "memo");
            this.memo = memo;
            return this;
        }

        public Builder fixedCompensations(List<FixedCompensations> fixedCompensations) {
            Utils.checkNotNull(fixedCompensations, "fixedCompensations");
            this.fixedCompensations = Optional.ofNullable(fixedCompensations);
            return this;
        }

        public Builder fixedCompensations(Optional<? extends List<FixedCompensations>> fixedCompensations) {
            Utils.checkNotNull(fixedCompensations, "fixedCompensations");
            this.fixedCompensations = fixedCompensations;
            return this;
        }

        public Builder hourlyCompensations(List<HourlyCompensations> hourlyCompensations) {
            Utils.checkNotNull(hourlyCompensations, "hourlyCompensations");
            this.hourlyCompensations = Optional.ofNullable(hourlyCompensations);
            return this;
        }

        public Builder hourlyCompensations(Optional<? extends List<HourlyCompensations>> hourlyCompensations) {
            Utils.checkNotNull(hourlyCompensations, "hourlyCompensations");
            this.hourlyCompensations = hourlyCompensations;
            return this;
        }

        /**
         * An array of all paid time off the employee is eligible for this pay period. Each paid time off object can be the name or the specific policy_uuid.
         */
        public Builder paidTimeOff(List<PaidTimeOff> paidTimeOff) {
            Utils.checkNotNull(paidTimeOff, "paidTimeOff");
            this.paidTimeOff = Optional.ofNullable(paidTimeOff);
            return this;
        }

        /**
         * An array of all paid time off the employee is eligible for this pay period. Each paid time off object can be the name or the specific policy_uuid.
         */
        public Builder paidTimeOff(Optional<? extends List<PaidTimeOff>> paidTimeOff) {
            Utils.checkNotNull(paidTimeOff, "paidTimeOff");
            this.paidTimeOff = paidTimeOff;
            return this;
        }
        
        public EmployeeCompensations build() {
            return new EmployeeCompensations(
                employeeUuid,
                version,
                excluded,
                paymentMethod,
                memo,
                fixedCompensations,
                hourlyCompensations,
                paidTimeOff);
        }
    }
}

