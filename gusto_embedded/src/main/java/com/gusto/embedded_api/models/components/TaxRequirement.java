/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

package com.gusto.embedded_api.models.components;


import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.gusto.embedded_api.utils.Utils;
import java.lang.Override;
import java.lang.String;
import java.lang.SuppressWarnings;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import org.openapitools.jackson.nullable.JsonNullable;


public class TaxRequirement {

    /**
     * An identifier for an individual requirement. Uniqueness is guaranteed within a requirement set.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("key")
    private Optional<String> key;

    /**
     * An array of references to other requirements within the requirement set. This requirement is only applicable if all referenced requirements have values matching the corresponding `value`. The primary use-case is dynamically hiding and showing requirements as values change. E.g. Show Requirement-B when Requirement-A has been answered with `false`. To be explicit, an empty array means the requirement is applicable.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("applicable_if")
    private Optional<? extends List<ApplicableIf>> applicableIf;

    /**
     * A customer facing description of the requirement
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("label")
    private Optional<String> label;

    /**
     * A more detailed customer facing description of the requirement
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("description")
    private Optional<String> description;

    /**
     * The "answer"
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("value")
    private JsonNullable<String> value;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("metadata")
    private Optional<? extends TaxRequirementMetadata> metadata;

    @JsonCreator
    public TaxRequirement(
            @JsonProperty("key") Optional<String> key,
            @JsonProperty("applicable_if") Optional<? extends List<ApplicableIf>> applicableIf,
            @JsonProperty("label") Optional<String> label,
            @JsonProperty("description") Optional<String> description,
            @JsonProperty("value") JsonNullable<String> value,
            @JsonProperty("metadata") Optional<? extends TaxRequirementMetadata> metadata) {
        Utils.checkNotNull(key, "key");
        Utils.checkNotNull(applicableIf, "applicableIf");
        Utils.checkNotNull(label, "label");
        Utils.checkNotNull(description, "description");
        Utils.checkNotNull(value, "value");
        Utils.checkNotNull(metadata, "metadata");
        this.key = key;
        this.applicableIf = applicableIf;
        this.label = label;
        this.description = description;
        this.value = value;
        this.metadata = metadata;
    }
    
    public TaxRequirement() {
        this(Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), JsonNullable.undefined(), Optional.empty());
    }

    /**
     * An identifier for an individual requirement. Uniqueness is guaranteed within a requirement set.
     */
    @JsonIgnore
    public Optional<String> key() {
        return key;
    }

    /**
     * An array of references to other requirements within the requirement set. This requirement is only applicable if all referenced requirements have values matching the corresponding `value`. The primary use-case is dynamically hiding and showing requirements as values change. E.g. Show Requirement-B when Requirement-A has been answered with `false`. To be explicit, an empty array means the requirement is applicable.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<ApplicableIf>> applicableIf() {
        return (Optional<List<ApplicableIf>>) applicableIf;
    }

    /**
     * A customer facing description of the requirement
     */
    @JsonIgnore
    public Optional<String> label() {
        return label;
    }

    /**
     * A more detailed customer facing description of the requirement
     */
    @JsonIgnore
    public Optional<String> description() {
        return description;
    }

    /**
     * The "answer"
     */
    @JsonIgnore
    public JsonNullable<String> value() {
        return value;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<TaxRequirementMetadata> metadata() {
        return (Optional<TaxRequirementMetadata>) metadata;
    }

    public final static Builder builder() {
        return new Builder();
    }

    /**
     * An identifier for an individual requirement. Uniqueness is guaranteed within a requirement set.
     */
    public TaxRequirement withKey(String key) {
        Utils.checkNotNull(key, "key");
        this.key = Optional.ofNullable(key);
        return this;
    }

    /**
     * An identifier for an individual requirement. Uniqueness is guaranteed within a requirement set.
     */
    public TaxRequirement withKey(Optional<String> key) {
        Utils.checkNotNull(key, "key");
        this.key = key;
        return this;
    }

    /**
     * An array of references to other requirements within the requirement set. This requirement is only applicable if all referenced requirements have values matching the corresponding `value`. The primary use-case is dynamically hiding and showing requirements as values change. E.g. Show Requirement-B when Requirement-A has been answered with `false`. To be explicit, an empty array means the requirement is applicable.
     */
    public TaxRequirement withApplicableIf(List<ApplicableIf> applicableIf) {
        Utils.checkNotNull(applicableIf, "applicableIf");
        this.applicableIf = Optional.ofNullable(applicableIf);
        return this;
    }

    /**
     * An array of references to other requirements within the requirement set. This requirement is only applicable if all referenced requirements have values matching the corresponding `value`. The primary use-case is dynamically hiding and showing requirements as values change. E.g. Show Requirement-B when Requirement-A has been answered with `false`. To be explicit, an empty array means the requirement is applicable.
     */
    public TaxRequirement withApplicableIf(Optional<? extends List<ApplicableIf>> applicableIf) {
        Utils.checkNotNull(applicableIf, "applicableIf");
        this.applicableIf = applicableIf;
        return this;
    }

    /**
     * A customer facing description of the requirement
     */
    public TaxRequirement withLabel(String label) {
        Utils.checkNotNull(label, "label");
        this.label = Optional.ofNullable(label);
        return this;
    }

    /**
     * A customer facing description of the requirement
     */
    public TaxRequirement withLabel(Optional<String> label) {
        Utils.checkNotNull(label, "label");
        this.label = label;
        return this;
    }

    /**
     * A more detailed customer facing description of the requirement
     */
    public TaxRequirement withDescription(String description) {
        Utils.checkNotNull(description, "description");
        this.description = Optional.ofNullable(description);
        return this;
    }

    /**
     * A more detailed customer facing description of the requirement
     */
    public TaxRequirement withDescription(Optional<String> description) {
        Utils.checkNotNull(description, "description");
        this.description = description;
        return this;
    }

    /**
     * The "answer"
     */
    public TaxRequirement withValue(String value) {
        Utils.checkNotNull(value, "value");
        this.value = JsonNullable.of(value);
        return this;
    }

    /**
     * The "answer"
     */
    public TaxRequirement withValue(JsonNullable<String> value) {
        Utils.checkNotNull(value, "value");
        this.value = value;
        return this;
    }

    public TaxRequirement withMetadata(TaxRequirementMetadata metadata) {
        Utils.checkNotNull(metadata, "metadata");
        this.metadata = Optional.ofNullable(metadata);
        return this;
    }

    public TaxRequirement withMetadata(Optional<? extends TaxRequirementMetadata> metadata) {
        Utils.checkNotNull(metadata, "metadata");
        this.metadata = metadata;
        return this;
    }
    
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        TaxRequirement other = (TaxRequirement) o;
        return 
            Objects.deepEquals(this.key, other.key) &&
            Objects.deepEquals(this.applicableIf, other.applicableIf) &&
            Objects.deepEquals(this.label, other.label) &&
            Objects.deepEquals(this.description, other.description) &&
            Objects.deepEquals(this.value, other.value) &&
            Objects.deepEquals(this.metadata, other.metadata);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(
            key,
            applicableIf,
            label,
            description,
            value,
            metadata);
    }
    
    @Override
    public String toString() {
        return Utils.toString(TaxRequirement.class,
                "key", key,
                "applicableIf", applicableIf,
                "label", label,
                "description", description,
                "value", value,
                "metadata", metadata);
    }
    
    public final static class Builder {
 
        private Optional<String> key = Optional.empty();
 
        private Optional<? extends List<ApplicableIf>> applicableIf = Optional.empty();
 
        private Optional<String> label = Optional.empty();
 
        private Optional<String> description = Optional.empty();
 
        private JsonNullable<String> value = JsonNullable.undefined();
 
        private Optional<? extends TaxRequirementMetadata> metadata = Optional.empty();  
        
        private Builder() {
          // force use of static builder() method
        }

        /**
         * An identifier for an individual requirement. Uniqueness is guaranteed within a requirement set.
         */
        public Builder key(String key) {
            Utils.checkNotNull(key, "key");
            this.key = Optional.ofNullable(key);
            return this;
        }

        /**
         * An identifier for an individual requirement. Uniqueness is guaranteed within a requirement set.
         */
        public Builder key(Optional<String> key) {
            Utils.checkNotNull(key, "key");
            this.key = key;
            return this;
        }

        /**
         * An array of references to other requirements within the requirement set. This requirement is only applicable if all referenced requirements have values matching the corresponding `value`. The primary use-case is dynamically hiding and showing requirements as values change. E.g. Show Requirement-B when Requirement-A has been answered with `false`. To be explicit, an empty array means the requirement is applicable.
         */
        public Builder applicableIf(List<ApplicableIf> applicableIf) {
            Utils.checkNotNull(applicableIf, "applicableIf");
            this.applicableIf = Optional.ofNullable(applicableIf);
            return this;
        }

        /**
         * An array of references to other requirements within the requirement set. This requirement is only applicable if all referenced requirements have values matching the corresponding `value`. The primary use-case is dynamically hiding and showing requirements as values change. E.g. Show Requirement-B when Requirement-A has been answered with `false`. To be explicit, an empty array means the requirement is applicable.
         */
        public Builder applicableIf(Optional<? extends List<ApplicableIf>> applicableIf) {
            Utils.checkNotNull(applicableIf, "applicableIf");
            this.applicableIf = applicableIf;
            return this;
        }

        /**
         * A customer facing description of the requirement
         */
        public Builder label(String label) {
            Utils.checkNotNull(label, "label");
            this.label = Optional.ofNullable(label);
            return this;
        }

        /**
         * A customer facing description of the requirement
         */
        public Builder label(Optional<String> label) {
            Utils.checkNotNull(label, "label");
            this.label = label;
            return this;
        }

        /**
         * A more detailed customer facing description of the requirement
         */
        public Builder description(String description) {
            Utils.checkNotNull(description, "description");
            this.description = Optional.ofNullable(description);
            return this;
        }

        /**
         * A more detailed customer facing description of the requirement
         */
        public Builder description(Optional<String> description) {
            Utils.checkNotNull(description, "description");
            this.description = description;
            return this;
        }

        /**
         * The "answer"
         */
        public Builder value(String value) {
            Utils.checkNotNull(value, "value");
            this.value = JsonNullable.of(value);
            return this;
        }

        /**
         * The "answer"
         */
        public Builder value(JsonNullable<String> value) {
            Utils.checkNotNull(value, "value");
            this.value = value;
            return this;
        }

        public Builder metadata(TaxRequirementMetadata metadata) {
            Utils.checkNotNull(metadata, "metadata");
            this.metadata = Optional.ofNullable(metadata);
            return this;
        }

        public Builder metadata(Optional<? extends TaxRequirementMetadata> metadata) {
            Utils.checkNotNull(metadata, "metadata");
            this.metadata = metadata;
            return this;
        }
        
        public TaxRequirement build() {
            return new TaxRequirement(
                key,
                applicableIf,
                label,
                description,
                value,
                metadata);
        }
    }
}

