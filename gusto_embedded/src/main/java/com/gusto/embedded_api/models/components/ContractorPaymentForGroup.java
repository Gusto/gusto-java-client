/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

package com.gusto.embedded_api.models.components;


import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.gusto.embedded_api.utils.Utils;
import java.lang.Boolean;
import java.lang.Override;
import java.lang.String;
import java.lang.SuppressWarnings;
import java.util.Objects;
import java.util.Optional;

/**
 * ContractorPaymentForGroup - The representation of a single contractor payment.
 */

public class ContractorPaymentForGroup {

    /**
     * The unique identifier of the contractor payment in Gusto.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("uuid")
    private Optional<String> uuid;

    /**
     * The UUID of the contractor.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("contractor_uuid")
    private Optional<String> contractorUuid;

    /**
     * The bonus amount in the payment.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("bonus")
    private Optional<String> bonus;

    /**
     * The number of hours worked for the payment.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("hours")
    private Optional<String> hours;

    /**
     * The payment method.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("payment_method")
    private Optional<? extends ContractorPaymentForGroupPaymentMethod> paymentMethod;

    /**
     * The reimbursement amount in the payment.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("reimbursement")
    private Optional<String> reimbursement;

    /**
     * The status of the contractor payment.  Will transition to `Funded` during payments processing if the payment should be funded, i.e. has `Direct Deposit` for payment method. Contractors payments with `Check` payment method will remain `Unfunded`.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("status")
    private Optional<? extends ContractorPaymentForGroupStatus> status;

    /**
     * The rate per hour worked for the payment.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("hourly_rate")
    private Optional<String> hourlyRate;

    /**
     * Determine if the contractor payment can be cancelled.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("may_cancel")
    private Optional<Boolean> mayCancel;

    /**
     * The fixed wage of the payment, regardless of hours worked.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("wage")
    private Optional<String> wage;

    /**
     * The wage type for the payment.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("wage_type")
    private Optional<? extends ContractorPaymentForGroupWageType> wageType;

    /**
     * (hours * hourly_rate) + wage + bonus
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("wage_total")
    private Optional<String> wageTotal;

    @JsonCreator
    public ContractorPaymentForGroup(
            @JsonProperty("uuid") Optional<String> uuid,
            @JsonProperty("contractor_uuid") Optional<String> contractorUuid,
            @JsonProperty("bonus") Optional<String> bonus,
            @JsonProperty("hours") Optional<String> hours,
            @JsonProperty("payment_method") Optional<? extends ContractorPaymentForGroupPaymentMethod> paymentMethod,
            @JsonProperty("reimbursement") Optional<String> reimbursement,
            @JsonProperty("status") Optional<? extends ContractorPaymentForGroupStatus> status,
            @JsonProperty("hourly_rate") Optional<String> hourlyRate,
            @JsonProperty("may_cancel") Optional<Boolean> mayCancel,
            @JsonProperty("wage") Optional<String> wage,
            @JsonProperty("wage_type") Optional<? extends ContractorPaymentForGroupWageType> wageType,
            @JsonProperty("wage_total") Optional<String> wageTotal) {
        Utils.checkNotNull(uuid, "uuid");
        Utils.checkNotNull(contractorUuid, "contractorUuid");
        Utils.checkNotNull(bonus, "bonus");
        Utils.checkNotNull(hours, "hours");
        Utils.checkNotNull(paymentMethod, "paymentMethod");
        Utils.checkNotNull(reimbursement, "reimbursement");
        Utils.checkNotNull(status, "status");
        Utils.checkNotNull(hourlyRate, "hourlyRate");
        Utils.checkNotNull(mayCancel, "mayCancel");
        Utils.checkNotNull(wage, "wage");
        Utils.checkNotNull(wageType, "wageType");
        Utils.checkNotNull(wageTotal, "wageTotal");
        this.uuid = uuid;
        this.contractorUuid = contractorUuid;
        this.bonus = bonus;
        this.hours = hours;
        this.paymentMethod = paymentMethod;
        this.reimbursement = reimbursement;
        this.status = status;
        this.hourlyRate = hourlyRate;
        this.mayCancel = mayCancel;
        this.wage = wage;
        this.wageType = wageType;
        this.wageTotal = wageTotal;
    }
    
    public ContractorPaymentForGroup() {
        this(Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty());
    }

    /**
     * The unique identifier of the contractor payment in Gusto.
     */
    @JsonIgnore
    public Optional<String> uuid() {
        return uuid;
    }

    /**
     * The UUID of the contractor.
     */
    @JsonIgnore
    public Optional<String> contractorUuid() {
        return contractorUuid;
    }

    /**
     * The bonus amount in the payment.
     */
    @JsonIgnore
    public Optional<String> bonus() {
        return bonus;
    }

    /**
     * The number of hours worked for the payment.
     */
    @JsonIgnore
    public Optional<String> hours() {
        return hours;
    }

    /**
     * The payment method.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<ContractorPaymentForGroupPaymentMethod> paymentMethod() {
        return (Optional<ContractorPaymentForGroupPaymentMethod>) paymentMethod;
    }

    /**
     * The reimbursement amount in the payment.
     */
    @JsonIgnore
    public Optional<String> reimbursement() {
        return reimbursement;
    }

    /**
     * The status of the contractor payment.  Will transition to `Funded` during payments processing if the payment should be funded, i.e. has `Direct Deposit` for payment method. Contractors payments with `Check` payment method will remain `Unfunded`.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<ContractorPaymentForGroupStatus> status() {
        return (Optional<ContractorPaymentForGroupStatus>) status;
    }

    /**
     * The rate per hour worked for the payment.
     */
    @JsonIgnore
    public Optional<String> hourlyRate() {
        return hourlyRate;
    }

    /**
     * Determine if the contractor payment can be cancelled.
     */
    @JsonIgnore
    public Optional<Boolean> mayCancel() {
        return mayCancel;
    }

    /**
     * The fixed wage of the payment, regardless of hours worked.
     */
    @JsonIgnore
    public Optional<String> wage() {
        return wage;
    }

    /**
     * The wage type for the payment.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<ContractorPaymentForGroupWageType> wageType() {
        return (Optional<ContractorPaymentForGroupWageType>) wageType;
    }

    /**
     * (hours * hourly_rate) + wage + bonus
     */
    @JsonIgnore
    public Optional<String> wageTotal() {
        return wageTotal;
    }

    public final static Builder builder() {
        return new Builder();
    }

    /**
     * The unique identifier of the contractor payment in Gusto.
     */
    public ContractorPaymentForGroup withUuid(String uuid) {
        Utils.checkNotNull(uuid, "uuid");
        this.uuid = Optional.ofNullable(uuid);
        return this;
    }

    /**
     * The unique identifier of the contractor payment in Gusto.
     */
    public ContractorPaymentForGroup withUuid(Optional<String> uuid) {
        Utils.checkNotNull(uuid, "uuid");
        this.uuid = uuid;
        return this;
    }

    /**
     * The UUID of the contractor.
     */
    public ContractorPaymentForGroup withContractorUuid(String contractorUuid) {
        Utils.checkNotNull(contractorUuid, "contractorUuid");
        this.contractorUuid = Optional.ofNullable(contractorUuid);
        return this;
    }

    /**
     * The UUID of the contractor.
     */
    public ContractorPaymentForGroup withContractorUuid(Optional<String> contractorUuid) {
        Utils.checkNotNull(contractorUuid, "contractorUuid");
        this.contractorUuid = contractorUuid;
        return this;
    }

    /**
     * The bonus amount in the payment.
     */
    public ContractorPaymentForGroup withBonus(String bonus) {
        Utils.checkNotNull(bonus, "bonus");
        this.bonus = Optional.ofNullable(bonus);
        return this;
    }

    /**
     * The bonus amount in the payment.
     */
    public ContractorPaymentForGroup withBonus(Optional<String> bonus) {
        Utils.checkNotNull(bonus, "bonus");
        this.bonus = bonus;
        return this;
    }

    /**
     * The number of hours worked for the payment.
     */
    public ContractorPaymentForGroup withHours(String hours) {
        Utils.checkNotNull(hours, "hours");
        this.hours = Optional.ofNullable(hours);
        return this;
    }

    /**
     * The number of hours worked for the payment.
     */
    public ContractorPaymentForGroup withHours(Optional<String> hours) {
        Utils.checkNotNull(hours, "hours");
        this.hours = hours;
        return this;
    }

    /**
     * The payment method.
     */
    public ContractorPaymentForGroup withPaymentMethod(ContractorPaymentForGroupPaymentMethod paymentMethod) {
        Utils.checkNotNull(paymentMethod, "paymentMethod");
        this.paymentMethod = Optional.ofNullable(paymentMethod);
        return this;
    }

    /**
     * The payment method.
     */
    public ContractorPaymentForGroup withPaymentMethod(Optional<? extends ContractorPaymentForGroupPaymentMethod> paymentMethod) {
        Utils.checkNotNull(paymentMethod, "paymentMethod");
        this.paymentMethod = paymentMethod;
        return this;
    }

    /**
     * The reimbursement amount in the payment.
     */
    public ContractorPaymentForGroup withReimbursement(String reimbursement) {
        Utils.checkNotNull(reimbursement, "reimbursement");
        this.reimbursement = Optional.ofNullable(reimbursement);
        return this;
    }

    /**
     * The reimbursement amount in the payment.
     */
    public ContractorPaymentForGroup withReimbursement(Optional<String> reimbursement) {
        Utils.checkNotNull(reimbursement, "reimbursement");
        this.reimbursement = reimbursement;
        return this;
    }

    /**
     * The status of the contractor payment.  Will transition to `Funded` during payments processing if the payment should be funded, i.e. has `Direct Deposit` for payment method. Contractors payments with `Check` payment method will remain `Unfunded`.
     */
    public ContractorPaymentForGroup withStatus(ContractorPaymentForGroupStatus status) {
        Utils.checkNotNull(status, "status");
        this.status = Optional.ofNullable(status);
        return this;
    }

    /**
     * The status of the contractor payment.  Will transition to `Funded` during payments processing if the payment should be funded, i.e. has `Direct Deposit` for payment method. Contractors payments with `Check` payment method will remain `Unfunded`.
     */
    public ContractorPaymentForGroup withStatus(Optional<? extends ContractorPaymentForGroupStatus> status) {
        Utils.checkNotNull(status, "status");
        this.status = status;
        return this;
    }

    /**
     * The rate per hour worked for the payment.
     */
    public ContractorPaymentForGroup withHourlyRate(String hourlyRate) {
        Utils.checkNotNull(hourlyRate, "hourlyRate");
        this.hourlyRate = Optional.ofNullable(hourlyRate);
        return this;
    }

    /**
     * The rate per hour worked for the payment.
     */
    public ContractorPaymentForGroup withHourlyRate(Optional<String> hourlyRate) {
        Utils.checkNotNull(hourlyRate, "hourlyRate");
        this.hourlyRate = hourlyRate;
        return this;
    }

    /**
     * Determine if the contractor payment can be cancelled.
     */
    public ContractorPaymentForGroup withMayCancel(boolean mayCancel) {
        Utils.checkNotNull(mayCancel, "mayCancel");
        this.mayCancel = Optional.ofNullable(mayCancel);
        return this;
    }

    /**
     * Determine if the contractor payment can be cancelled.
     */
    public ContractorPaymentForGroup withMayCancel(Optional<Boolean> mayCancel) {
        Utils.checkNotNull(mayCancel, "mayCancel");
        this.mayCancel = mayCancel;
        return this;
    }

    /**
     * The fixed wage of the payment, regardless of hours worked.
     */
    public ContractorPaymentForGroup withWage(String wage) {
        Utils.checkNotNull(wage, "wage");
        this.wage = Optional.ofNullable(wage);
        return this;
    }

    /**
     * The fixed wage of the payment, regardless of hours worked.
     */
    public ContractorPaymentForGroup withWage(Optional<String> wage) {
        Utils.checkNotNull(wage, "wage");
        this.wage = wage;
        return this;
    }

    /**
     * The wage type for the payment.
     */
    public ContractorPaymentForGroup withWageType(ContractorPaymentForGroupWageType wageType) {
        Utils.checkNotNull(wageType, "wageType");
        this.wageType = Optional.ofNullable(wageType);
        return this;
    }

    /**
     * The wage type for the payment.
     */
    public ContractorPaymentForGroup withWageType(Optional<? extends ContractorPaymentForGroupWageType> wageType) {
        Utils.checkNotNull(wageType, "wageType");
        this.wageType = wageType;
        return this;
    }

    /**
     * (hours * hourly_rate) + wage + bonus
     */
    public ContractorPaymentForGroup withWageTotal(String wageTotal) {
        Utils.checkNotNull(wageTotal, "wageTotal");
        this.wageTotal = Optional.ofNullable(wageTotal);
        return this;
    }

    /**
     * (hours * hourly_rate) + wage + bonus
     */
    public ContractorPaymentForGroup withWageTotal(Optional<String> wageTotal) {
        Utils.checkNotNull(wageTotal, "wageTotal");
        this.wageTotal = wageTotal;
        return this;
    }
    
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        ContractorPaymentForGroup other = (ContractorPaymentForGroup) o;
        return 
            Objects.deepEquals(this.uuid, other.uuid) &&
            Objects.deepEquals(this.contractorUuid, other.contractorUuid) &&
            Objects.deepEquals(this.bonus, other.bonus) &&
            Objects.deepEquals(this.hours, other.hours) &&
            Objects.deepEquals(this.paymentMethod, other.paymentMethod) &&
            Objects.deepEquals(this.reimbursement, other.reimbursement) &&
            Objects.deepEquals(this.status, other.status) &&
            Objects.deepEquals(this.hourlyRate, other.hourlyRate) &&
            Objects.deepEquals(this.mayCancel, other.mayCancel) &&
            Objects.deepEquals(this.wage, other.wage) &&
            Objects.deepEquals(this.wageType, other.wageType) &&
            Objects.deepEquals(this.wageTotal, other.wageTotal);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(
            uuid,
            contractorUuid,
            bonus,
            hours,
            paymentMethod,
            reimbursement,
            status,
            hourlyRate,
            mayCancel,
            wage,
            wageType,
            wageTotal);
    }
    
    @Override
    public String toString() {
        return Utils.toString(ContractorPaymentForGroup.class,
                "uuid", uuid,
                "contractorUuid", contractorUuid,
                "bonus", bonus,
                "hours", hours,
                "paymentMethod", paymentMethod,
                "reimbursement", reimbursement,
                "status", status,
                "hourlyRate", hourlyRate,
                "mayCancel", mayCancel,
                "wage", wage,
                "wageType", wageType,
                "wageTotal", wageTotal);
    }
    
    public final static class Builder {
 
        private Optional<String> uuid = Optional.empty();
 
        private Optional<String> contractorUuid = Optional.empty();
 
        private Optional<String> bonus = Optional.empty();
 
        private Optional<String> hours = Optional.empty();
 
        private Optional<? extends ContractorPaymentForGroupPaymentMethod> paymentMethod = Optional.empty();
 
        private Optional<String> reimbursement = Optional.empty();
 
        private Optional<? extends ContractorPaymentForGroupStatus> status = Optional.empty();
 
        private Optional<String> hourlyRate = Optional.empty();
 
        private Optional<Boolean> mayCancel = Optional.empty();
 
        private Optional<String> wage = Optional.empty();
 
        private Optional<? extends ContractorPaymentForGroupWageType> wageType = Optional.empty();
 
        private Optional<String> wageTotal = Optional.empty();  
        
        private Builder() {
          // force use of static builder() method
        }

        /**
         * The unique identifier of the contractor payment in Gusto.
         */
        public Builder uuid(String uuid) {
            Utils.checkNotNull(uuid, "uuid");
            this.uuid = Optional.ofNullable(uuid);
            return this;
        }

        /**
         * The unique identifier of the contractor payment in Gusto.
         */
        public Builder uuid(Optional<String> uuid) {
            Utils.checkNotNull(uuid, "uuid");
            this.uuid = uuid;
            return this;
        }

        /**
         * The UUID of the contractor.
         */
        public Builder contractorUuid(String contractorUuid) {
            Utils.checkNotNull(contractorUuid, "contractorUuid");
            this.contractorUuid = Optional.ofNullable(contractorUuid);
            return this;
        }

        /**
         * The UUID of the contractor.
         */
        public Builder contractorUuid(Optional<String> contractorUuid) {
            Utils.checkNotNull(contractorUuid, "contractorUuid");
            this.contractorUuid = contractorUuid;
            return this;
        }

        /**
         * The bonus amount in the payment.
         */
        public Builder bonus(String bonus) {
            Utils.checkNotNull(bonus, "bonus");
            this.bonus = Optional.ofNullable(bonus);
            return this;
        }

        /**
         * The bonus amount in the payment.
         */
        public Builder bonus(Optional<String> bonus) {
            Utils.checkNotNull(bonus, "bonus");
            this.bonus = bonus;
            return this;
        }

        /**
         * The number of hours worked for the payment.
         */
        public Builder hours(String hours) {
            Utils.checkNotNull(hours, "hours");
            this.hours = Optional.ofNullable(hours);
            return this;
        }

        /**
         * The number of hours worked for the payment.
         */
        public Builder hours(Optional<String> hours) {
            Utils.checkNotNull(hours, "hours");
            this.hours = hours;
            return this;
        }

        /**
         * The payment method.
         */
        public Builder paymentMethod(ContractorPaymentForGroupPaymentMethod paymentMethod) {
            Utils.checkNotNull(paymentMethod, "paymentMethod");
            this.paymentMethod = Optional.ofNullable(paymentMethod);
            return this;
        }

        /**
         * The payment method.
         */
        public Builder paymentMethod(Optional<? extends ContractorPaymentForGroupPaymentMethod> paymentMethod) {
            Utils.checkNotNull(paymentMethod, "paymentMethod");
            this.paymentMethod = paymentMethod;
            return this;
        }

        /**
         * The reimbursement amount in the payment.
         */
        public Builder reimbursement(String reimbursement) {
            Utils.checkNotNull(reimbursement, "reimbursement");
            this.reimbursement = Optional.ofNullable(reimbursement);
            return this;
        }

        /**
         * The reimbursement amount in the payment.
         */
        public Builder reimbursement(Optional<String> reimbursement) {
            Utils.checkNotNull(reimbursement, "reimbursement");
            this.reimbursement = reimbursement;
            return this;
        }

        /**
         * The status of the contractor payment.  Will transition to `Funded` during payments processing if the payment should be funded, i.e. has `Direct Deposit` for payment method. Contractors payments with `Check` payment method will remain `Unfunded`.
         */
        public Builder status(ContractorPaymentForGroupStatus status) {
            Utils.checkNotNull(status, "status");
            this.status = Optional.ofNullable(status);
            return this;
        }

        /**
         * The status of the contractor payment.  Will transition to `Funded` during payments processing if the payment should be funded, i.e. has `Direct Deposit` for payment method. Contractors payments with `Check` payment method will remain `Unfunded`.
         */
        public Builder status(Optional<? extends ContractorPaymentForGroupStatus> status) {
            Utils.checkNotNull(status, "status");
            this.status = status;
            return this;
        }

        /**
         * The rate per hour worked for the payment.
         */
        public Builder hourlyRate(String hourlyRate) {
            Utils.checkNotNull(hourlyRate, "hourlyRate");
            this.hourlyRate = Optional.ofNullable(hourlyRate);
            return this;
        }

        /**
         * The rate per hour worked for the payment.
         */
        public Builder hourlyRate(Optional<String> hourlyRate) {
            Utils.checkNotNull(hourlyRate, "hourlyRate");
            this.hourlyRate = hourlyRate;
            return this;
        }

        /**
         * Determine if the contractor payment can be cancelled.
         */
        public Builder mayCancel(boolean mayCancel) {
            Utils.checkNotNull(mayCancel, "mayCancel");
            this.mayCancel = Optional.ofNullable(mayCancel);
            return this;
        }

        /**
         * Determine if the contractor payment can be cancelled.
         */
        public Builder mayCancel(Optional<Boolean> mayCancel) {
            Utils.checkNotNull(mayCancel, "mayCancel");
            this.mayCancel = mayCancel;
            return this;
        }

        /**
         * The fixed wage of the payment, regardless of hours worked.
         */
        public Builder wage(String wage) {
            Utils.checkNotNull(wage, "wage");
            this.wage = Optional.ofNullable(wage);
            return this;
        }

        /**
         * The fixed wage of the payment, regardless of hours worked.
         */
        public Builder wage(Optional<String> wage) {
            Utils.checkNotNull(wage, "wage");
            this.wage = wage;
            return this;
        }

        /**
         * The wage type for the payment.
         */
        public Builder wageType(ContractorPaymentForGroupWageType wageType) {
            Utils.checkNotNull(wageType, "wageType");
            this.wageType = Optional.ofNullable(wageType);
            return this;
        }

        /**
         * The wage type for the payment.
         */
        public Builder wageType(Optional<? extends ContractorPaymentForGroupWageType> wageType) {
            Utils.checkNotNull(wageType, "wageType");
            this.wageType = wageType;
            return this;
        }

        /**
         * (hours * hourly_rate) + wage + bonus
         */
        public Builder wageTotal(String wageTotal) {
            Utils.checkNotNull(wageTotal, "wageTotal");
            this.wageTotal = Optional.ofNullable(wageTotal);
            return this;
        }

        /**
         * (hours * hourly_rate) + wage + bonus
         */
        public Builder wageTotal(Optional<String> wageTotal) {
            Utils.checkNotNull(wageTotal, "wageTotal");
            this.wageTotal = wageTotal;
            return this;
        }
        
        public ContractorPaymentForGroup build() {
            return new ContractorPaymentForGroup(
                uuid,
                contractorUuid,
                bonus,
                hours,
                paymentMethod,
                reimbursement,
                status,
                hourlyRate,
                mayCancel,
                wage,
                wageType,
                wageTotal);
        }
    }
}

